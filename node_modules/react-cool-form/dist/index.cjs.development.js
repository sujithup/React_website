'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _objectWithoutPropertiesLoose = require('@babel/runtime/helpers/objectWithoutPropertiesLoose');
var _extends = require('@babel/runtime/helpers/extends');
var react = require('react');
var lite = require('dequal/lite');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _objectWithoutPropertiesLoose__default = /*#__PURE__*/_interopDefaultLegacy(_objectWithoutPropertiesLoose);
var _extends__default = /*#__PURE__*/_interopDefaultLegacy(_extends);

var useLatest = (function (val) {
  var ref = react.useRef(val);
  react.useEffect(function () {
    ref.current = val;
  });
  return ref;
});

var arrayToMap = (function (arr) {
  return arr.reduce(function (obj, key) {
    obj[key] = true;
    return obj;
  }, {});
});

var isObject = (function (value) {
  return value !== null && typeof value === "object";
});

var isFileList = (function (value) {
  return value instanceof FileList;
});

var cloneObject = function cloneObject(object) {
  if (object instanceof Event) throw new Error("Unable to clone event.");
  if (!isObject(object) || isFileList(object)) return object;
  if (object instanceof Date) return new Date(object.getTime());
  if (Array.isArray(object)) return object.map(function (val) {
    return cloneObject(val);
  });
  if (isObject(object)) return Object.keys(object).reduce(function (obj, key) {
    obj[key] = cloneObject(object[key]);
    return obj;
  }, {});
  throw new Error("Unable to clone object.");
};

var compact = (function (arr) {
  return arr.filter(Boolean);
});

var isPlainObject = (function (value) {
  return !Array.isArray(value) && !(value instanceof Date) && isObject(value);
});

var deepMerge = function deepMerge() {
  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
    objects[_key] = arguments[_key];
  }

  return objects.reduce(function (prev, obj) {
    Object.keys(obj).forEach(function (key) {
      var prevValue = prev[key];
      var currValue = obj[key];

      if (Array.isArray(prevValue) && Array.isArray(currValue)) {
        prev[key] = [].concat(prevValue, currValue);
      } else if (isPlainObject(prevValue) && isPlainObject(currValue)) {
        prev[key] = deepMerge(prevValue, currValue);
      } else {
        prev[key] = currValue;
      }
    });
    return prev;
  }, {});
};

var isUndefined = (function (value) {
  return value === undefined;
});

var filterErrors = function filterErrors(error, touched) {
  if (!isPlainObject(error)) return touched ? error : undefined;
  return Object.keys(error).reduce(function (obj, key) {
    var nextErrors = filterErrors(error[key], touched[key] || false);

    if (!isUndefined(nextErrors)) {
      obj[key] = nextErrors;
    } else {
      delete obj[key];
    }

    return obj;
  }, {});
};

var stringToPath = (function (str) {
  if (typeof str !== "string") throw new TypeError("Expected a string.");
  if (!str.length) return [];
  return compact(str.split(/[.[\]]+/));
});

var get = (function (object, path, defaultValue) {
  if (!isPlainObject(object) || !path) return defaultValue;
  var value = stringToPath(path).reduce(function (obj, key) {
    return (obj || {})[key];
  }, object);
  return isUndefined(value) ? defaultValue : value;
});

var getIsDirty = function getIsDirty(dirty) {
  var search = function search(dty, found) {
    if (found === void 0) {
      found = [];
    }

    for (var _i = 0, _Object$values = Object.values(dty); _i < _Object$values.length; _i++) {
      var val = _Object$values[_i];

      if (val === true) {
        found.push(val);
        return found;
      }

      if (isPlainObject(val)) search(val, found);
    }

    return found;
  };

  return !!search(dirty).length;
};

var isFunction = (function (value) {
  return typeof value === "function";
});

var isAsyncFunction = (function (value) {
  return isFunction(value) && value.constructor.name === "AsyncFunction";
});

var isCheckboxInput = (function (field) {
  return field.type === "checkbox";
});

var isEmptyObject = (function (value) {
  return isPlainObject(value) && !Object.keys(value).length;
});

var isFieldElement = (function (element) {
  return /INPUT|TEXTAREA|SELECT/.test(element.tagName);
});

var isFileInput = (function (field) {
  return field.type === "file";
});

var isInputElement = (function (element) {
  return element.tagName === "INPUT";
});

var isMultipleSelect = (function (field) {
  return field.type === "select-multiple";
});

var isNumberInput = (function (field) {
  return field.type === "number";
});

var isRadioInput = (function (field) {
  return field.type === "radio";
});

var isRangeInput = (function (field) {
  return field.type === "range";
});

var runWithLowPriority = (function (callback) {
  return (window.requestIdleCallback || function (cb) {
    var start = Date.now();
    return setTimeout(function () {
      return cb({
        didTimeout: false,
        timeRemaining: function timeRemaining() {
          return Math.max(0, 50 - (Date.now() - start));
        }
      });
    }, 1);
  })(callback, {
    timeout: 2000
  });
});

var set = (function (object, path, value, immutable) {
  if (immutable === void 0) {
    immutable = false;
  }

  if (!isPlainObject(object)) throw new TypeError("Expected an object.");
  var segs = stringToPath(path);
  var newObject = immutable ? cloneObject(object) : object;
  segs.slice(0, -1).reduce(function (obj, key, idx) {
    var nextIsNumber = !Number.isNaN(Number(segs[idx + 1]));
    if (isPlainObject(obj[key]) && !nextIsNumber) return obj[key];
    obj[key] = nextIsNumber ? [] : {};
    return obj[key];
  }, newObject)[segs[segs.length - 1] || ""] = value;
  return newObject;
});

/* eslint-disable no-prototype-builtins */

var unset = (function (object, path, immutable) {
  if (immutable === void 0) {
    immutable = false;
  }

  if (!isPlainObject(object)) throw new TypeError("Expected an object.");
  var refObject = immutable ? cloneObject(object) : object;
  var newObject = refObject;

  if (newObject.hasOwnProperty(path)) {
    delete newObject[path];
    return refObject;
  }

  var segs = stringToPath(path);
  if (!segs.length) return refObject;
  var last = segs.pop();
  var target = segs.reduce(function (obj, key) {
    return (obj || {})[key];
  }, newObject);
  if (isObject(target) && target.hasOwnProperty(last)) delete target[last];
  return refObject;
});

var warn = (function () {
  var _console;

  if ("development" !== "production") (_console = console).warn.apply(_console, arguments);
});

var useState = (function (initialState, onChange) {
  var _useReducer = react.useReducer(function (c) {
    return c + 1;
  }, 0),
      forceUpdate = _useReducer[1];

  var stateRef = react.useRef(initialState);
  var usedStateRef = react.useRef({});
  var onChangeRef = useLatest(onChange || function () {
    return undefined;
  });
  var setStateRef = react.useCallback(function (path, value, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        fieldPath = _ref.fieldPath,
        _ref$shouldUpdate = _ref.shouldUpdate,
        shouldUpdate = _ref$shouldUpdate === void 0 ? true : _ref$shouldUpdate;

    var key = path.split(".")[0];

    if (!key) {
      if (!lite.dequal(stateRef.current, value)) {
        stateRef.current = value;
        forceUpdate();
        onChangeRef.current(stateRef.current);
      }

      return;
    }

    if (path !== "values" && key === "values" || !lite.dequal(get(stateRef.current, path), value)) {
      var state = set(stateRef.current, path, value, true);
      var errors = state.errors,
          dirty = state.dirty,
          prevIsDirty = state.isDirty,
          prevIsValid = state.isValid;
      var prevSubmitCount = state.submitCount;
      var isDirty = key === "dirty" ? getIsDirty(dirty) : prevIsDirty;
      var isValid = key === "errors" ? isEmptyObject(errors) : prevIsValid;
      var submitCount = key === "isSubmitting" && value ? prevSubmitCount += 1 : prevSubmitCount;
      stateRef.current = _extends__default['default']({}, state, {
        isDirty: isDirty,
        isValid: isValid,
        submitCount: submitCount
      });
      path = fieldPath || path;

      if (shouldUpdate && (Object.keys(usedStateRef.current).some(function (k) {
        return path.startsWith(k) || k.startsWith(path);
      }) || usedStateRef.current.isDirty && isDirty !== prevIsDirty || usedStateRef.current.isValid && isValid !== prevIsValid)) {
        forceUpdate();
        onChangeRef.current(stateRef.current);
      }
    }
  }, [onChangeRef]);
  var setUsedStateRef = react.useCallback(function (path, unset) {
    if (unset === void 0) {
      unset = false;
    }

    if (unset) {
      delete usedStateRef.current[path];
    } else {
      usedStateRef.current[path] = true;
    }
  }, []);
  return {
    stateRef: stateRef,
    setStateRef: setStateRef,
    setUsedStateRef: setUsedStateRef
  };
});

var useIsoLayoutEffect = typeof window === "undefined" ? react.useEffect : react.useLayoutEffect;

var useForm = (function (_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$defaultValues = _ref.defaultValues,
      defaultValues = _ref$defaultValues === void 0 ? {} : _ref$defaultValues,
      validate = _ref.validate,
      _ref$validateOnChange = _ref.validateOnChange,
      validateOnChange = _ref$validateOnChange === void 0 ? true : _ref$validateOnChange,
      _ref$validateOnBlur = _ref.validateOnBlur,
      validateOnBlur = _ref$validateOnBlur === void 0 ? true : _ref$validateOnBlur,
      _ref$builtInValidatio = _ref.builtInValidationMode,
      builtInValidationMode = _ref$builtInValidatio === void 0 ? "message" : _ref$builtInValidatio,
      _ref$shouldRemoveFiel = _ref.shouldRemoveField,
      shouldRemoveField = _ref$shouldRemoveFiel === void 0 ? true : _ref$shouldRemoveFiel,
      _ref$excludeFields = _ref.excludeFields,
      excludeFields = _ref$excludeFields === void 0 ? [] : _ref$excludeFields,
      onReset = _ref.onReset,
      onSubmit = _ref.onSubmit,
      onError = _ref.onError,
      debug = _ref.debug;

  var isInitRef = react.useRef(true);
  var formRef = react.useRef(null);
  var fieldsRef = react.useRef({});
  var fieldArgsRef = react.useRef({});
  var controllersRef = react.useRef({});
  var excludeFieldsRef = react.useRef(arrayToMap(excludeFields));
  var changedFieldRef = react.useRef();
  var formValidatorRef = useLatest(validate);
  var fieldValidatorsRef = react.useRef({});
  var onResetRef = useLatest(onReset || function () {
    return undefined;
  });
  var onSubmitRef = useLatest(onSubmit || function () {
    return undefined;
  });
  var onErrorRef = useLatest(onError || function () {
    return undefined;
  });
  var defaultValuesRef = react.useRef(defaultValues);
  var initialStateRef = react.useRef({
    values: defaultValuesRef.current,
    touched: {},
    errors: {},
    isDirty: false,
    dirty: {},
    isValidating: false,
    isValid: true,
    isSubmitting: false,
    isSubmitted: false,
    submitCount: 0
  });

  var _useState = useState(initialStateRef.current, debug),
      stateRef = _useState.stateRef,
      setStateRef = _useState.setStateRef,
      setUsedStateRef = _useState.setUsedStateRef;

  var getFields = react.useCallback(function (form) {
    return Array.from(form.querySelectorAll("input,textarea,select")).filter(function (element) {
      var field = element;
      var type = field.type,
          name = field.name,
          rcfExclude = field.dataset.rcfExclude;
      if (/button|image|submit|reset/.test(type)) return false;

      if (rcfExclude && !name) {
        warn('💡 react-cool-form > field: Missing the "name" attribute.');
        return false;
      }

      return controllersRef.current[name] || !(rcfExclude || excludeFieldsRef.current[name]);
    }).reduce(function (acc, cur) {
      var field = cur;
      var name = field.name;
      acc[name] = _extends__default['default']({}, acc[name], {
        field: cur
      });
      if (isCheckboxInput(field) || isRadioInput(field)) acc[name].options = acc[name].options ? [].concat(acc[name].options, [cur]) : [cur];
      return acc;
    }, {});
  }, []);
  var handleUnset = react.useCallback(function (path, fieldPath, target, name) {
    return setStateRef(path, unset(target, name, true), {
      fieldPath: fieldPath
    });
  }, [setStateRef]);
  var fieldRef = react.useCallback(function (validateOrOptions) {
    return function (field) {
      if (!(field != null && field.name) || controllersRef.current[field.name] || excludeFieldsRef.current[field.name]) return;

      if (isFunction(validateOrOptions)) {
        fieldValidatorsRef.current[field.name] = validateOrOptions;
        return;
      }

      var validator = validateOrOptions.validate,
          parsers = _objectWithoutPropertiesLoose__default['default'](validateOrOptions, ["validate"]);

      if (validator) fieldValidatorsRef.current[field.name] = validator;
      fieldArgsRef.current[field.name] = parsers;
    };
  }, []);
  var getNodeValue = react.useCallback(function (name) {
    var _find;

    var _fieldsRef$current$na = fieldsRef.current[name],
        field = _fieldsRef$current$na.field,
        options = _fieldsRef$current$na.options;
    var value = field.value;

    if (isInputElement(field)) {
      var _fieldArgsRef$current, _fieldArgsRef$current2;

      if ((_fieldArgsRef$current = fieldArgsRef.current[name]) != null && _fieldArgsRef$current.valueAsNumber) {
        value = field.valueAsNumber;
        return value;
      }

      if ((_fieldArgsRef$current2 = fieldArgsRef.current[name]) != null && _fieldArgsRef$current2.valueAsDate) {
        value = field.valueAsDate;
        return value;
      }
    }

    if (isNumberInput(field) || isRangeInput(field)) value = field.valueAsNumber || "";

    if (isCheckboxInput(field)) {
      if (options) {
        var checkboxes = options;

        if (options.length > 1) {
          value = checkboxes.filter(function (checkbox) {
            return checkbox.checked;
          }).map(function (checkbox) {
            return checkbox.value;
          });
        } else {
          value = checkboxes[0].checked;
        }
      } else {
        var checkValues = get(stateRef.current.values, field.name);

        if (Array.isArray(checkValues)) {
          checkValues = new Set(checkValues);

          if (field.checked) {
            checkValues.add(value);
          } else {
            checkValues["delete"](value);
          }

          value = Array.from(checkValues);
        } else {
          value = field.checked;
        }
      }
    }

    if (isRadioInput(field) && options) value = ((_find = options.find(function (radio) {
      return radio.checked;
    })) == null ? void 0 : _find.value) || "";
    if (isMultipleSelect(field) && !options) value = Array.from(field.options).filter(function (option) {
      return option.selected;
    }).map(function (option) {
      return option.value;
    });
    if (isFileInput(field)) value = field.files;
    return value;
  }, [stateRef]);
  var setNodeValue = react.useCallback(function (name, value) {
    if (!fieldsRef.current[name] || controllersRef.current[name]) return;
    var _fieldsRef$current$na2 = fieldsRef.current[name],
        field = _fieldsRef$current$na2.field,
        options = _fieldsRef$current$na2.options;

    if (isCheckboxInput(field)) {
      var checkboxes = options;

      if (checkboxes.length > 1) {
        checkboxes.forEach(function (checkbox) {
          checkbox.checked = Array.isArray(value) ? value.includes(checkbox.value) : !!value;
        });
      } else {
        checkboxes[0].checked = !!value;
      }
    } else if (isRadioInput(field)) {
      options.forEach(function (radio) {
        radio.checked = radio.value === value;
      });
    } else if (isMultipleSelect(field) && Array.isArray(value)) {
      Array.from(field.options).forEach(function (option) {
        option.selected = !!value.includes(option.value);
      });
    } else if (isFileInput(field)) {
      if (isFileList(value)) field.files = value;
      if (!value) field.value = "";
    } else {
      field.value = value != null ? value : "";
    }
  }, []);
  var setDefaultValue = react.useCallback(function (name, value) {
    if (!isUndefined(get(initialStateRef.current.values, name))) return;
    initialStateRef.current.values = set(initialStateRef.current.values, name, value, true);
    setStateRef("values." + name, get(initialStateRef.current.values, name), {
      shouldUpdate: !isInitRef.current
    });
  }, [setStateRef]);
  var setNodesOrStateValue = react.useCallback(function (values, checkDefaultValues, fields) {
    if (checkDefaultValues === void 0) {
      checkDefaultValues = false;
    }

    if (fields === void 0) {
      fields = Object.values(fieldsRef.current);
    }

    return fields.forEach(function (field) {
      var name = isPlainObject(field) ? field.field.name : field;
      if (controllersRef.current[name]) return;
      var value = get(values, name);
      if (!isUndefined(value)) setNodeValue(name, value);

      if (checkDefaultValues) {
        var defaultValue = get(defaultValuesRef.current, name);
        setDefaultValue(name, !isUndefined(defaultValue) ? defaultValue : getNodeValue(name));
      }
    });
  }, [getNodeValue, setDefaultValue, setNodeValue]);
  var getState = react.useCallback(function (path, _temp2) {
    var _ref2 = _temp2 === void 0 ? {} : _temp2,
        target = _ref2.target,
        _ref2$watch = _ref2.watch,
        watch = _ref2$watch === void 0 ? true : _ref2$watch,
        _ref2$errorWithTouche = _ref2.errorWithTouched,
        errorWithTouched = _ref2$errorWithTouche === void 0 ? false : _ref2$errorWithTouche;

    if (!path) return undefined;

    var getPath = function getPath(p) {
      if (p === "values" && !target && watch) warn('💡 react-cool-form > getState: Get the "values" alone may cause unnecessary re-renders. If you know what you\'re doing, please ignore this warning. See: https://react-cool-form.netlify.app/docs/getting-started/form-state#best-practices');
      p = target ? target + "." + p : p;
      if (watch) setUsedStateRef(p);
      return p;
    };

    var errorsEnhancer = function errorsEnhancer(p, state) {
      if (!watch || !errorWithTouched || !p.startsWith("errors") || !state || isEmptyObject(state)) return state;
      p = p.replace("errors", "touched");
      setUsedStateRef(p);
      return filterErrors(state, get(stateRef.current, p));
    };

    var state;

    if (Array.isArray(path)) {
      state = path.map(function (p) {
        p = getPath(p);
        return errorsEnhancer(p, get(stateRef.current, p));
      });
    } else if (isPlainObject(path)) {
      var paths = path;
      state = Object.keys(paths).reduce(function (s, key) {
        path = getPath(paths[key]);
        s[key] = errorsEnhancer(path, get(stateRef.current, path));
        return s;
      }, {});
    } else {
      path = getPath(path);
      state = errorsEnhancer(path, get(stateRef.current, path));
    }

    return state;
  }, [setUsedStateRef, stateRef]);
  var setError = react.useCallback(function (name, error) {
    error = isFunction(error) ? error(get(stateRef.current.errors, name)) : error;

    if (error) {
      setStateRef("errors." + name, error);
    } else {
      handleUnset("errors", "errors." + name, stateRef.current.errors, name);
    }
  }, [handleUnset, setStateRef, stateRef]);
  var clearErrors = react.useCallback(function (name) {
    if (!name) {
      setStateRef("errors", {});
    } else if (Array.isArray(name)) {
      name.forEach(function (n) {
        return handleUnset("errors", "errors." + n, stateRef.current.errors, n);
      });
    } else {
      handleUnset("errors", "errors." + name, stateRef.current.errors, name);
    }
  }, [handleUnset, setStateRef, stateRef]);
  var runBuiltInValidation = react.useCallback(function (name) {
    if (builtInValidationMode === false || !fieldsRef.current[name]) return undefined;
    var field = fieldsRef.current[name].field;
    if (builtInValidationMode === "message") return field.validationMessage;

    for (var k in field.validity) {
      // @ts-expect-error
      if (k !== "valid" && field.validity[k]) return k;
    }

    return undefined;
  }, [builtInValidationMode]);
  var runAllBuiltInValidation = react.useCallback(function () {
    if (builtInValidationMode === false) return {};
    return Object.keys(fieldsRef.current).reduce(function (errors, name) {
      var error = runBuiltInValidation(name);
      errors = _extends__default['default']({}, errors, error ? set({}, name, error) : {});
      return errors;
    }, {});
  }, [builtInValidationMode, runBuiltInValidation]);
  var runFieldValidation = react.useCallback(async function (name) {
    if (!fieldValidatorsRef.current[name]) return undefined;

    try {
      var error = await fieldValidatorsRef.current[name](get(stateRef.current.values, name), stateRef.current.values);
      return error;
    } catch (exception) {
      warn("\uD83D\uDCA1 react-cool-form > validate " + name + ": ", exception);
      throw exception;
    }
  }, [stateRef]);
  var runAllFieldsValidation = react.useCallback(function () {
    var promises = Object.keys(fieldValidatorsRef.current).map(function (name) {
      return runFieldValidation(name);
    });
    return Promise.all(promises).then(function (errors) {
      return Object.keys(fieldValidatorsRef.current).reduce(function (acc, cur, idx) {
        acc = _extends__default['default']({}, acc, errors[idx] ? set({}, cur, errors[idx]) : {});
        return acc;
      }, {});
    });
  }, [runFieldValidation]);
  var runFormValidation = react.useCallback(async function (name) {
    if (!formValidatorRef.current) return name ? undefined : {};

    try {
      var errors = await formValidatorRef.current(stateRef.current.values);
      if (name) return get(errors, name);
      return isPlainObject(errors) ? errors : {};
    } catch (exception) {
      warn("\uD83D\uDCA1 react-cool-form > validate form: ", exception);
      throw exception;
    }
  }, [formValidatorRef, stateRef]);
  var validateField = react.useCallback(async function (name) {
    var hasAsyncValidator = isAsyncFunction(formValidatorRef.current) || isAsyncFunction(fieldValidatorsRef.current[name]);
    if (hasAsyncValidator) setStateRef("isValidating", true);

    try {
      var error = (await runFormValidation(name)) || (await runFieldValidation(name)) || runBuiltInValidation(name);
      setError(name, error);
      if (hasAsyncValidator) setStateRef("isValidating", false);
      return error;
    } catch (exception) {
      return exception;
    }
  }, [formValidatorRef, runBuiltInValidation, runFieldValidation, runFormValidation, setError, setStateRef]);
  var validateFieldWithLowPriority = react.useCallback(function (name) {
    return runWithLowPriority(function () {
      return validateField(name);
    });
  }, [validateField]);
  var validateForm = react.useCallback(function () {
    setStateRef("isValidating", true);
    return Promise.all([runAllBuiltInValidation(), runAllFieldsValidation(), runFormValidation()]).then(function (errors) {
      var errs = deepMerge.apply(void 0, errors);
      setStateRef("errors", errs);
      setStateRef("isValidating", false);
      return errs;
    });
  }, [runAllBuiltInValidation, runAllFieldsValidation, runFormValidation, setStateRef]);
  var runValidation = react.useCallback(function (name) {
    if (!name) return validateForm().then(function (errors) {
      return isEmptyObject(errors);
    });
    if (Array.isArray(name)) return Promise.all(name.map(function (n) {
      return validateField(n);
    })).then(function (errors) {
      return !compact(errors).length;
    });
    return validateField(name).then(function (error) {
      return !error;
    });
  }, [validateField, validateForm]);
  var setTouched = react.useCallback(function (name, isTouched, shouldValidate) {
    if (isTouched === void 0) {
      isTouched = true;
    }

    if (shouldValidate === void 0) {
      shouldValidate = validateOnBlur;
    }

    if (isTouched) {
      setStateRef("touched." + name, true);
    } else {
      handleUnset("touched", "touched." + name, stateRef.current.touched, name);
    }

    if (shouldValidate) validateFieldWithLowPriority(name);
  }, [handleUnset, setStateRef, stateRef, validateFieldWithLowPriority, validateOnBlur]);
  var setTouchedMaybeValidate = react.useCallback(function (name) {
    return setTouched(name, true, validateOnChange ? name !== changedFieldRef.current : undefined);
  }, [setTouched, validateOnChange]);
  var setDirty = react.useCallback(function (name, isDirty) {
    if (isDirty === void 0) {
      isDirty = true;
    }

    if (isDirty) {
      setStateRef("dirty." + name, true);
    } else {
      handleUnset("dirty", "dirty." + name, stateRef.current.dirty, name);
    }
  }, [handleUnset, setStateRef, stateRef]);
  var setDirtyIfNeeded = react.useCallback(function (name) {
    return setDirty(name, get(stateRef.current.values, name) !== get(initialStateRef.current.values, name));
  }, [setDirty, stateRef]);
  var setValue = react.useCallback(function (name, value, _temp3) {
    var _ref3 = _temp3 === void 0 ? {} : _temp3,
        _ref3$shouldValidate = _ref3.shouldValidate,
        shouldValidate = _ref3$shouldValidate === void 0 ? validateOnChange : _ref3$shouldValidate,
        _ref3$shouldTouched = _ref3.shouldTouched,
        shouldTouched = _ref3$shouldTouched === void 0 ? true : _ref3$shouldTouched,
        _ref3$shouldDirty = _ref3.shouldDirty,
        shouldDirty = _ref3$shouldDirty === void 0 ? true : _ref3$shouldDirty;

    value = isFunction(value) ? value(get(stateRef.current.values, name)) : value;

    if (!isUndefined(value)) {
      setStateRef("values." + name, value);
    } else {
      handleUnset("values", "values." + name, stateRef.current.values, name);
    }

    setNodeValue(name, value);
    if (shouldTouched) setTouched(name, true, false);
    if (shouldDirty) setDirtyIfNeeded(name);
    if (shouldValidate) validateFieldWithLowPriority(name);
  }, [handleUnset, setDirtyIfNeeded, setNodeValue, setStateRef, setTouched, stateRef, validateFieldWithLowPriority, validateOnChange]);
  var getOptions = react.useCallback(function () {
    return {
      formState: stateRef.current,
      setValue: setValue,
      setTouched: setTouched,
      setDirty: setDirty,
      setError: setError,
      clearErrors: clearErrors,
      runValidation: runValidation,
      reset: reset,
      submit: submit
    };
  }, [clearErrors, // @ts-expect-error
  reset, runValidation, setDirty, setError, setTouched, setValue, stateRef, // @ts-expect-error
  submit]);
  var reset = react.useCallback(function (values, exclude, e) {
    e == null ? void 0 : e.preventDefault();
    e == null ? void 0 : e.stopPropagation();

    var state = _extends__default['default']({}, stateRef.current);

    var skip = arrayToMap(exclude || []);
    Object.keys(state).forEach(function (key) {
      if (skip[key]) return;

      if (key === "values") {
        var nextValues = (isFunction(values) ? values(stateRef.current.values) : values) || initialStateRef.current.values;
        state[key] = nextValues;
        initialStateRef.current.values = nextValues;
        setNodesOrStateValue(initialStateRef.current.values, !!values);
      } else {
        // @ts-expect-error
        state[key] = initialStateRef.current[key];
      }
    });
    setStateRef("", state);
    onResetRef.current(state.values, getOptions(), e);
  }, [getOptions, onResetRef, setNodesOrStateValue, setStateRef, stateRef]);
  var submit = react.useCallback(async function (e) {
    e == null ? void 0 : e.preventDefault();
    e == null ? void 0 : e.stopPropagation();
    var nextTouched = Object.keys(_extends__default['default']({}, fieldsRef.current, controllersRef.current)).reduce(function (touched, name) {
      touched = set(touched, name, true, true);
      return touched;
    }, stateRef.current.touched);
    setStateRef("touched", nextTouched);
    setStateRef("isSubmitting", true);

    try {
      var errors = await validateForm();

      if (!isEmptyObject(errors)) {
        onErrorRef.current(errors, getOptions(), e);
        return {
          errors: errors
        };
      }

      await onSubmitRef.current(stateRef.current.values, getOptions(), e);
      setStateRef("isSubmitted", true);
      return {
        values: stateRef.current.values
      };
    } catch (exception) {
      warn("\uD83D\uDCA1 react-cool-form > submit: ", exception);
      throw exception;
    } finally {
      setStateRef("isSubmitting", false);
    }
  }, [getOptions, onErrorRef, onSubmitRef, setStateRef, stateRef, validateForm]);
  var handleChangeEvent = react.useCallback(function (name, value) {
    setStateRef("values." + name, value);
    setDirtyIfNeeded(name);
    if (validateOnChange) validateFieldWithLowPriority(name);
  }, [setDirtyIfNeeded, setStateRef, validateFieldWithLowPriority, validateOnChange]);
  var controller = react.useCallback(function (name, _temp4) {
    var _ref5;

    var _ref4 = _temp4 === void 0 ? {} : _temp4,
        validator = _ref4.validate,
        value = _ref4.value,
        defaultValue = _ref4.defaultValue,
        parse = _ref4.parse,
        format = _ref4.format,
        _onChange = _ref4.onChange,
        _onBlur = _ref4.onBlur;

    if (!name) {
      warn('💡 react-cool-form > controller: Missing the "name" parameter.');
      return undefined;
    }

    controllersRef.current[name] = true;
    if (validator) fieldValidatorsRef.current[name] = validator;
    var val = get(defaultValuesRef.current, name);
    defaultValue = !isUndefined(val) ? val : defaultValue;
    if (!isUndefined(defaultValue)) setDefaultValue(name, defaultValue);
    value = !isUndefined(value) ? value : getState("values." + name);
    value = (_ref5 = format ? format(value) : value) != null ? _ref5 : "";
    return {
      name: name,
      value: value,
      onChange: function onChange() {
        var v;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (parse) {
          v = parse.apply(void 0, args);
        } else {
          var e = args[0];
          v = (e == null ? void 0 : e.nativeEvent) instanceof Event && isFieldElement(e.target) ? getNodeValue(name) : e;
        }

        handleChangeEvent(name, v);
        if (_onChange) _onChange.apply(void 0, args.concat([v]));
        changedFieldRef.current = name;
      },
      onBlur: function onBlur(e) {
        setTouchedMaybeValidate(name);
        if (_onBlur) _onBlur(e);
        changedFieldRef.current = undefined;
      }
    };
  }, [getNodeValue, getState, handleChangeEvent, setDefaultValue, setTouchedMaybeValidate]);
  useIsoLayoutEffect(function () {
    if (!formRef.current) return;
    fieldsRef.current = getFields(formRef.current);
    setNodesOrStateValue(initialStateRef.current.values, true);
    isInitRef.current = false;
  }, [getFields, setNodesOrStateValue]);
  react.useEffect(function () {
    if (!formRef.current) return function () {
      return null;
    };

    var handleChange = function handleChange(_ref6) {
      var target = _ref6.target;
      var _ref7 = target,
          name = _ref7.name;

      if (!name) {
        warn('💡 react-cool-form > field: Missing the "name" attribute.');
        return;
      }

      if (fieldsRef.current[name] && !controllersRef.current[name]) {
        var _fieldArgsRef$current3;

        var parse = (_fieldArgsRef$current3 = fieldArgsRef.current[name]) == null ? void 0 : _fieldArgsRef$current3.parse;
        var value = getNodeValue(name);
        handleChangeEvent(name, parse ? parse(value) : value);
        changedFieldRef.current = name;
      }
    };

    var handleBlur = function handleBlur(_ref8) {
      var target = _ref8.target;
      if (!isFieldElement(target)) return;
      var _ref9 = target,
          name = _ref9.name;

      if (fieldsRef.current[name] && !controllersRef.current[name]) {
        setTouchedMaybeValidate(name);
        changedFieldRef.current = undefined;
      }
    };

    var handleSubmit = function handleSubmit(e) {
      return submit(e);
    };

    var handleReset = function handleReset(e) {
      return reset(null, null, e);
    };

    var form = formRef.current;
    form.addEventListener("input", handleChange);
    form.addEventListener("focusout", handleBlur);
    form.addEventListener("submit", handleSubmit);
    form.addEventListener("reset", handleReset);
    var observer = new MutationObserver(function (_ref10) {
      var type = _ref10[0].type;
      if (type !== "childList") return;
      var fields = getFields(form);
      var values = stateRef.current.values;
      if (shouldRemoveField) Object.keys(fieldsRef.current).forEach(function (name) {
        if (fields[name]) return;
        handleUnset("values", "values." + name, stateRef.current.values, name);
        handleUnset("touched", "touched." + name, stateRef.current.touched, name);
        handleUnset("dirty", "dirty." + name, stateRef.current.dirty, name);
        handleUnset("errors", "errors." + name, stateRef.current.errors, name);
        setUsedStateRef(name, true);
        initialStateRef.current.values = unset(initialStateRef.current.values, name, true);
        delete fieldArgsRef.current[name];
        delete fieldValidatorsRef.current[name];
        delete controllersRef.current[name];
      });
      var addedNodes = [];
      Object.keys(fields).forEach(function (name) {
        if (fieldsRef.current[name] || controllersRef.current[name]) return;
        var defaultValue = get(defaultValuesRef.current, name);
        if (!isUndefined(defaultValue)) values = set(values, name, defaultValue, true);
        addedNodes.push(name);
      });
      fieldsRef.current = fields;
      if (addedNodes.length) setNodesOrStateValue(values, true, addedNodes);
    });
    observer.observe(form, {
      childList: true,
      subtree: true
    });
    return function () {
      form.removeEventListener("input", handleChange);
      form.removeEventListener("focusout", handleBlur);
      form.removeEventListener("submit", handleSubmit);
      form.removeEventListener("reset", handleReset);
      observer.disconnect();
    };
  }, [getFields, getNodeValue, handleChangeEvent, handleUnset, reset, setNodesOrStateValue, setTouchedMaybeValidate, setUsedStateRef, shouldRemoveField, stateRef, submit]);
  return {
    form: formRef,
    field: fieldRef,
    getState: getState,
    setValue: setValue,
    setTouched: setTouched,
    setDirty: setDirty,
    setError: setError,
    clearErrors: clearErrors,
    runValidation: runValidation,
    reset: reset,
    submit: submit,
    controller: controller
  };
});

exports.get = get;
exports.set = set;
exports.unset = unset;
exports.useForm = useForm;
//# sourceMappingURL=index.cjs.development.js.map
