{"version":3,"file":"index.umd.production.min.js","sources":["../node_modules/dequal/lite/index.mjs","../src/hooks/useLatest.ts","../src/utils/arrayToMap.ts","../src/utils/isObject.ts","../src/utils/isFileList.ts","../src/utils/cloneObject.ts","../src/utils/compact.ts","../src/utils/isPlainObject.ts","../src/utils/deepMerge.ts","../src/utils/isUndefined.ts","../src/utils/filterErrors.ts","../src/utils/stringToPath.ts","../src/utils/get.ts","../src/utils/isFunction.ts","../src/utils/isAsyncFunction.ts","../src/utils/isCheckboxInput.ts","../src/utils/isEmptyObject.ts","../src/utils/isFieldElement.ts","../src/utils/isFileInput.ts","../src/utils/isMultipleSelect.ts","../src/utils/isRadioInput.ts","../src/utils/set.ts","../src/utils/unset.ts","../src/hooks/useState.ts","../src/utils/getIsDirty.ts","../src/hooks/useIsoLayoutEffect.ts","../src/useForm.ts","../src/utils/isInputElement.ts","../src/utils/isNumberInput.ts","../src/utils/isRangeInput.ts","../src/utils/runWithLowPriority.ts"],"sourcesContent":["var has = Object.prototype.hasOwnProperty;\n\nexport function dequal(foo, bar) {\n\tvar ctor, len;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","import { MutableRefObject, useRef, useEffect } from \"react\";\n\nexport default <T>(val: T): MutableRefObject<T> => {\n  const ref = useRef(val);\n\n  useEffect(() => {\n    ref.current = val;\n  });\n\n  return ref;\n};\n","import { Map } from \"../types\";\n\nexport default (arr: any[]): Map =>\n  arr.reduce((obj, key) => {\n    obj[key] = true;\n    return obj;\n  }, {});\n","export default (value: unknown): value is Object =>\n  value !== null && typeof value === \"object\";\n","export default (value: unknown): value is FileList => value instanceof FileList;\n","import isObject from \"./isObject\";\nimport isFileList from \"./isFileList\";\n\nconst cloneObject = (object: unknown): any => {\n  if (object instanceof Event) throw new Error(\"Unable to clone event.\");\n\n  if (!isObject(object) || isFileList(object)) return object;\n\n  if (object instanceof Date) return new Date(object.getTime());\n\n  if (Array.isArray(object)) return object.map((val) => cloneObject(val));\n\n  if (isObject(object))\n    return Object.keys(object).reduce((obj: Record<string, any>, key) => {\n      obj[key] = cloneObject((object as Record<string, any>)[key]);\n      return obj;\n    }, {});\n\n  throw new Error(\"Unable to clone object.\");\n};\n\nexport default cloneObject;\n","export default (arr: any[]): any[] => arr.filter(Boolean);\n","import isObject from \"./isObject\";\n\nexport default (value: unknown): value is Object =>\n  !Array.isArray(value) && !(value instanceof Date) && isObject(value);\n","import isPlainObject from \"./isPlainObject\";\n\nconst deepMerge = (...objects: any[]): any =>\n  objects.reduce((prev, obj) => {\n    Object.keys(obj).forEach((key) => {\n      const prevValue = prev[key];\n      const currValue = obj[key];\n\n      if (Array.isArray(prevValue) && Array.isArray(currValue)) {\n        prev[key] = [...prevValue, ...currValue];\n      } else if (isPlainObject(prevValue) && isPlainObject(currValue)) {\n        prev[key] = deepMerge(prevValue, currValue);\n      } else {\n        prev[key] = currValue;\n      }\n    });\n\n    return prev;\n  }, {});\n\nexport default deepMerge;\n","export default (value: unknown): value is undefined => value === undefined;\n","import isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\n\nconst filterErrors = (error: unknown, touched: unknown): any => {\n  if (!isPlainObject(error)) return touched ? error : undefined;\n\n  return Object.keys(error).reduce((obj: Record<string, any>, key) => {\n    const nextErrors = filterErrors(\n      (error as Record<string, any>)[key],\n      (touched as Record<string, any>)[key] || false\n    );\n\n    if (!isUndefined(nextErrors)) {\n      obj[key] = nextErrors;\n    } else {\n      delete obj[key];\n    }\n\n    return obj;\n  }, {});\n};\n\nexport default filterErrors;\n","import compact from \"./compact\";\n\nexport default (str: string): string[] => {\n  if (typeof str !== \"string\") throw new TypeError(\"Expected a string.\");\n  if (!str.length) return [];\n\n  return compact(str.split(/[.[\\]]+/));\n};\n","import isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\nimport stringToPath from \"./stringToPath\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport default (object: any, path: string, defaultValue?: unknown): any => {\n  if (!isPlainObject(object) || !path) return defaultValue;\n\n  const value = stringToPath(path).reduce(\n    (obj, key) => (obj || {})[key],\n    object\n  );\n\n  return isUndefined(value) ? defaultValue : value;\n};\n","export default (value: unknown): value is Function =>\n  typeof value === \"function\";\n","import isFunction from \"./isFunction\";\n\nexport default (value: unknown): value is Promise<any> =>\n  isFunction(value) && value.constructor.name === \"AsyncFunction\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"checkbox\";\n","import isPlainObject from \"./isPlainObject\";\n\nexport default (value: unknown): value is Record<string, never> =>\n  isPlainObject(value) && !Object.keys(value).length;\n","import { FieldElement } from \"../types\";\n\nexport default (element: HTMLElement): element is FieldElement =>\n  /INPUT|TEXTAREA|SELECT/.test(element.tagName);\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"file\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLSelectElement =>\n  field.type === \"select-multiple\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"radio\";\n","import cloneObject from \"./cloneObject\";\nimport isPlainObject from \"./isPlainObject\";\nimport stringToPath from \"./stringToPath\";\n\nexport default (\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  object: any,\n  path: string,\n  value: unknown,\n  immutable = false\n): any => {\n  if (!isPlainObject(object)) throw new TypeError(\"Expected an object.\");\n\n  const segs = stringToPath(path);\n  const newObject = immutable ? cloneObject(object) : object;\n\n  segs.slice(0, -1).reduce((obj, key, idx) => {\n    const nextIsNumber = !Number.isNaN(Number(segs[idx + 1]));\n    if (isPlainObject(obj[key]) && !nextIsNumber) return obj[key];\n    obj[key] = nextIsNumber ? [] : {};\n    return obj[key];\n  }, newObject)[segs[segs.length - 1] || \"\"] = value;\n\n  return newObject;\n};\n","/* eslint-disable no-prototype-builtins */\n\nimport cloneObject from \"./cloneObject\";\nimport isPlainObject from \"./isPlainObject\";\nimport isObject from \"./isObject\";\nimport stringToPath from \"./stringToPath\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport default (object: any, path: string, immutable = false): any => {\n  if (!isPlainObject(object)) throw new TypeError(\"Expected an object.\");\n\n  const refObject = immutable ? cloneObject(object) : object;\n  const newObject = refObject;\n\n  if (newObject.hasOwnProperty(path)) {\n    delete newObject[path];\n    return refObject;\n  }\n\n  const segs = stringToPath(path);\n\n  if (!segs.length) return refObject;\n\n  const last = segs.pop() as string;\n  const target = segs.reduce((obj, key) => (obj || {})[key], newObject);\n\n  if (isObject(target) && target.hasOwnProperty(last)) delete target[last];\n\n  return refObject;\n};\n","import { useReducer, useRef, useCallback } from \"react\";\nimport { dequal } from \"dequal/lite\";\n\nimport {\n  Debug,\n  FormState,\n  FormStateReturn,\n  Map,\n  SetStateRef,\n  SetUsedStateRef,\n} from \"../types\";\nimport useLatest from \"./useLatest\";\nimport { get, getIsDirty, isEmptyObject, set } from \"../utils\";\n\nexport default <V>(\n  initialState: FormState<V>,\n  onChange?: Debug<V>\n): FormStateReturn<V> => {\n  const [, forceUpdate] = useReducer((c) => c + 1, 0);\n  const stateRef = useRef(initialState);\n  const usedStateRef = useRef<Map>({});\n  const onChangeRef = useLatest(onChange || (() => undefined));\n\n  const setStateRef = useCallback<SetStateRef>(\n    (path, value, { fieldPath, shouldUpdate = true } = {}) => {\n      const key = path.split(\".\")[0];\n\n      if (!key) {\n        if (!dequal(stateRef.current, value)) {\n          stateRef.current = value;\n          forceUpdate();\n          onChangeRef.current(stateRef.current);\n        }\n\n        return;\n      }\n\n      if (\n        (path !== \"values\" && key === \"values\") ||\n        !dequal(get(stateRef.current, path), value)\n      ) {\n        const state = set(stateRef.current, path, value, true);\n        const {\n          errors,\n          dirty,\n          isDirty: prevIsDirty,\n          isValid: prevIsValid,\n        } = state;\n        let { submitCount: prevSubmitCount } = state;\n        const isDirty = key === \"dirty\" ? getIsDirty(dirty) : prevIsDirty;\n        const isValid = key === \"errors\" ? isEmptyObject(errors) : prevIsValid;\n        const submitCount =\n          key === \"isSubmitting\" && value\n            ? (prevSubmitCount += 1)\n            : prevSubmitCount;\n\n        stateRef.current = { ...state, isDirty, isValid, submitCount };\n\n        path = fieldPath || path;\n\n        if (\n          shouldUpdate &&\n          (Object.keys(usedStateRef.current).some(\n            (k) => path.startsWith(k) || k.startsWith(path)\n          ) ||\n            (usedStateRef.current.isDirty && isDirty !== prevIsDirty) ||\n            (usedStateRef.current.isValid && isValid !== prevIsValid))\n        ) {\n          forceUpdate();\n          onChangeRef.current(stateRef.current);\n        }\n      }\n    },\n    [onChangeRef]\n  );\n\n  const setUsedStateRef = useCallback<SetUsedStateRef>(\n    (path, unset = false) => {\n      if (unset) {\n        delete usedStateRef.current[path];\n      } else {\n        usedStateRef.current[path] = true;\n      }\n    },\n    []\n  );\n\n  return { stateRef, setStateRef, setUsedStateRef };\n};\n","import isPlainObject from \"./isPlainObject\";\n\nconst getIsDirty = (dirty: object): boolean => {\n  const search = (dty: object, found: any[] = []) => {\n    for (const val of Object.values(dty)) {\n      if (val === true) {\n        found.push(val);\n        return found;\n      }\n\n      if (isPlainObject(val)) search(val, found);\n    }\n\n    return found;\n  };\n\n  return !!search(dirty).length;\n};\n\nexport default getIsDirty;\n","import { useEffect, useLayoutEffect } from \"react\";\n\nconst useIsoLayoutEffect =\n  typeof window === \"undefined\" ? useEffect : useLayoutEffect;\n\nexport default useIsoLayoutEffect;\n","/* eslint-disable @typescript-eslint/no-use-before-define */\n\nimport { useCallback, useEffect, useRef } from \"react\";\n\nimport {\n  ClearErrors,\n  Config,\n  Controller,\n  FieldArgs,\n  FieldElement,\n  FieldRef,\n  Fields,\n  FieldValidator,\n  FieldsValue,\n  FormErrors,\n  FormState,\n  FormValues,\n  GetState,\n  Map,\n  Reset,\n  Return,\n  RunValidation,\n  SetDirty,\n  SetError,\n  SetTouched,\n  SetValue,\n  Submit,\n} from \"./types\";\nimport { useIsoLayoutEffect, useLatest, useState } from \"./hooks\";\nimport {\n  arrayToMap,\n  compact,\n  deepMerge,\n  filterErrors,\n  get,\n  isAsyncFunction,\n  isCheckboxInput,\n  isEmptyObject,\n  isFieldElement,\n  isFileInput,\n  isFileList,\n  isFunction,\n  isInputElement,\n  isMultipleSelect,\n  isNumberInput,\n  isPlainObject,\n  isRadioInput,\n  isRangeInput,\n  isUndefined,\n  runWithLowPriority,\n  set,\n  unset,\n  warn,\n} from \"./utils\";\n\nexport default <V extends FormValues = FormValues>({\n  defaultValues = {} as V,\n  validate,\n  validateOnChange = true,\n  validateOnBlur = true,\n  builtInValidationMode = \"message\",\n  shouldRemoveField = true,\n  excludeFields = [],\n  onReset,\n  onSubmit,\n  onError,\n  debug,\n}: Config<V> = {}): Return<V> => {\n  const isInitRef = useRef(true);\n  const formRef = useRef<HTMLFormElement>(null);\n  const fieldsRef = useRef<Fields>({});\n  const fieldArgsRef = useRef<FieldArgs>({});\n  const controllersRef = useRef<Map>({});\n  const excludeFieldsRef = useRef<Map>(arrayToMap(excludeFields));\n  const changedFieldRef = useRef<string>();\n  const formValidatorRef = useLatest(validate);\n  const fieldValidatorsRef = useRef<Record<string, FieldValidator<V>>>({});\n  const onResetRef = useLatest(onReset || (() => undefined));\n  const onSubmitRef = useLatest(onSubmit || (() => undefined));\n  const onErrorRef = useLatest(onError || (() => undefined));\n  const defaultValuesRef = useRef(defaultValues);\n  const initialStateRef = useRef<FormState<V>>({\n    values: defaultValuesRef.current,\n    touched: {},\n    errors: {},\n    isDirty: false,\n    dirty: {},\n    isValidating: false,\n    isValid: true,\n    isSubmitting: false,\n    isSubmitted: false,\n    submitCount: 0,\n  });\n  const { stateRef, setStateRef, setUsedStateRef } = useState<V>(\n    initialStateRef.current,\n    debug\n  );\n\n  const getFields = useCallback(\n    (form: HTMLFormElement) =>\n      Array.from(form.querySelectorAll(\"input,textarea,select\"))\n        .filter((element) => {\n          const field = element as FieldElement;\n          const {\n            type,\n            name,\n            dataset: { rcfExclude },\n          } = field;\n\n          if (/button|image|submit|reset/.test(type)) return false;\n          if (rcfExclude && !name) {\n            warn('ðŸ’¡ react-cool-form > field: Missing the \"name\" attribute.');\n            return false;\n          }\n\n          return (\n            controllersRef.current[name] ||\n            !(rcfExclude || excludeFieldsRef.current[name])\n          );\n        })\n        .reduce((acc: Record<string, any>, cur) => {\n          const field = cur as FieldElement;\n          const { name } = field;\n\n          acc[name] = { ...acc[name], field: cur };\n\n          if (isCheckboxInput(field) || isRadioInput(field))\n            acc[name].options = acc[name].options\n              ? [...acc[name].options, cur]\n              : [cur];\n\n          return acc;\n        }, {}),\n    []\n  );\n\n  const handleUnset = useCallback(\n    (path: string, fieldPath: string, target: any, name: string) =>\n      setStateRef(path, unset(target, name, true), { fieldPath }),\n    [setStateRef]\n  );\n\n  const fieldRef = useCallback<FieldRef<V>>(\n    (validateOrOptions) => (field) => {\n      if (\n        !field?.name ||\n        controllersRef.current[field.name] ||\n        excludeFieldsRef.current[field.name]\n      )\n        return;\n\n      if (isFunction(validateOrOptions)) {\n        fieldValidatorsRef.current[field.name] = validateOrOptions;\n        return;\n      }\n\n      const { validate: validator, ...parsers } = validateOrOptions;\n\n      if (validator) fieldValidatorsRef.current[field.name] = validator;\n      fieldArgsRef.current[field.name] = parsers;\n    },\n    []\n  );\n\n  const getNodeValue = useCallback(\n    (name: string) => {\n      const { field, options } = fieldsRef.current[name];\n      let value = field.value as any;\n\n      if (isInputElement(field)) {\n        if (fieldArgsRef.current[name]?.valueAsNumber) {\n          value = field.valueAsNumber;\n          return value;\n        }\n        if (fieldArgsRef.current[name]?.valueAsDate) {\n          value = field.valueAsDate;\n          return value;\n        }\n      }\n\n      if (isNumberInput(field) || isRangeInput(field))\n        value = field.valueAsNumber || \"\";\n\n      if (isCheckboxInput(field)) {\n        if (options) {\n          const checkboxes = options as HTMLInputElement[];\n\n          if (options.length > 1) {\n            value = checkboxes\n              .filter((checkbox) => checkbox.checked)\n              .map((checkbox) => checkbox.value);\n          } else {\n            value = checkboxes[0].checked;\n          }\n        } else {\n          let checkValues = get(stateRef.current.values, field.name);\n\n          if (Array.isArray(checkValues)) {\n            checkValues = new Set(checkValues);\n\n            if (field.checked) {\n              checkValues.add(value);\n            } else {\n              checkValues.delete(value);\n            }\n\n            value = Array.from(checkValues);\n          } else {\n            value = field.checked;\n          }\n        }\n      }\n\n      if (isRadioInput(field) && options)\n        value =\n          (options as HTMLInputElement[]).find((radio) => radio.checked)\n            ?.value || \"\";\n\n      if (isMultipleSelect(field) && !options)\n        value = Array.from(field.options)\n          .filter((option) => option.selected)\n          .map((option) => option.value);\n\n      if (isFileInput(field)) value = field.files;\n\n      return value;\n    },\n    [stateRef]\n  );\n\n  const setNodeValue = useCallback((name: string, value: any) => {\n    if (!fieldsRef.current[name] || controllersRef.current[name]) return;\n\n    const { field, options } = fieldsRef.current[name];\n\n    if (isCheckboxInput(field)) {\n      const checkboxes = options as HTMLInputElement[];\n\n      if (checkboxes.length > 1) {\n        checkboxes.forEach((checkbox) => {\n          checkbox.checked = Array.isArray(value)\n            ? value.includes(checkbox.value)\n            : !!value;\n        });\n      } else {\n        checkboxes[0].checked = !!value;\n      }\n    } else if (isRadioInput(field)) {\n      (options as HTMLInputElement[]).forEach((radio) => {\n        radio.checked = radio.value === value;\n      });\n    } else if (isMultipleSelect(field) && Array.isArray(value)) {\n      Array.from(field.options).forEach((option) => {\n        option.selected = !!value.includes(option.value);\n      });\n    } else if (isFileInput(field)) {\n      if (isFileList(value)) field.files = value;\n      if (!value) field.value = \"\";\n    } else {\n      field.value = value ?? \"\";\n    }\n  }, []);\n\n  const setDefaultValue = useCallback(\n    (name: string, value: any) => {\n      if (!isUndefined(get(initialStateRef.current.values, name))) return;\n\n      initialStateRef.current.values = set(\n        initialStateRef.current.values,\n        name,\n        value,\n        true\n      );\n\n      setStateRef(`values.${name}`, get(initialStateRef.current.values, name), {\n        shouldUpdate: !isInitRef.current,\n      });\n    },\n    [setStateRef]\n  );\n\n  const setNodesOrStateValue = useCallback(\n    (\n      values: V,\n      checkDefaultValues = false,\n      fields: FieldsValue[] | string[] = Object.values(fieldsRef.current)\n    ) =>\n      fields.forEach((field: FieldsValue | string) => {\n        const name = isPlainObject(field)\n          ? (field as FieldsValue).field.name\n          : field;\n\n        if (controllersRef.current[name]) return;\n\n        const value = get(values, name);\n\n        if (!isUndefined(value)) setNodeValue(name, value);\n\n        if (checkDefaultValues) {\n          const defaultValue = get(defaultValuesRef.current, name);\n\n          setDefaultValue(\n            name,\n            !isUndefined(defaultValue) ? defaultValue : getNodeValue(name)\n          );\n        }\n      }),\n    [getNodeValue, setDefaultValue, setNodeValue]\n  );\n\n  const getState = useCallback<GetState>(\n    (path, { target, watch = true, errorWithTouched = false } = {}) => {\n      if (!path) return undefined;\n\n      const getPath = (p: string) => {\n        if (p === \"values\" && !target && watch)\n          warn(\n            'ðŸ’¡ react-cool-form > getState: Get the \"values\" alone may cause unnecessary re-renders. If you know what you\\'re doing, please ignore this warning. See: https://react-cool-form.netlify.app/docs/getting-started/form-state#best-practices'\n          );\n\n        p = target ? `${target}.${p}` : p;\n\n        if (watch) setUsedStateRef(p);\n\n        return p;\n      };\n      const errorsEnhancer = (p: string, state: any) => {\n        if (\n          !watch ||\n          !errorWithTouched ||\n          !p.startsWith(\"errors\") ||\n          !state ||\n          isEmptyObject(state)\n        )\n          return state;\n\n        p = p.replace(\"errors\", \"touched\");\n        setUsedStateRef(p);\n\n        return filterErrors(state, get(stateRef.current, p));\n      };\n      let state;\n\n      if (Array.isArray(path)) {\n        state = path.map((p) => {\n          p = getPath(p);\n          return errorsEnhancer(p, get(stateRef.current, p));\n        });\n      } else if (isPlainObject(path)) {\n        const paths = path as Record<string, string>;\n        state = Object.keys(paths).reduce((s: Record<string, any>, key) => {\n          path = getPath(paths[key]);\n          s[key] = errorsEnhancer(path, get(stateRef.current, path));\n          return s;\n        }, {});\n      } else {\n        path = getPath(path);\n        state = errorsEnhancer(path, get(stateRef.current, path));\n      }\n\n      return state;\n    },\n    [setUsedStateRef, stateRef]\n  );\n\n  const setError = useCallback<SetError>(\n    (name, error) => {\n      error = isFunction(error)\n        ? error(get(stateRef.current.errors, name))\n        : error;\n\n      if (error) {\n        setStateRef(`errors.${name}`, error);\n      } else {\n        handleUnset(\"errors\", `errors.${name}`, stateRef.current.errors, name);\n      }\n    },\n    [handleUnset, setStateRef, stateRef]\n  );\n\n  const clearErrors = useCallback<ClearErrors>(\n    (name) => {\n      if (!name) {\n        setStateRef(\"errors\", {});\n      } else if (Array.isArray(name)) {\n        name.forEach((n) =>\n          handleUnset(\"errors\", `errors.${n}`, stateRef.current.errors, n)\n        );\n      } else {\n        handleUnset(\"errors\", `errors.${name}`, stateRef.current.errors, name);\n      }\n    },\n    [handleUnset, setStateRef, stateRef]\n  );\n\n  const runBuiltInValidation = useCallback(\n    (name: string) => {\n      if (builtInValidationMode === false || !fieldsRef.current[name])\n        return undefined;\n\n      const { field } = fieldsRef.current[name];\n\n      if (builtInValidationMode === \"message\") return field.validationMessage;\n\n      for (const k in field.validity) {\n        // @ts-expect-error\n        if (k !== \"valid\" && field.validity[k]) return k;\n      }\n\n      return undefined;\n    },\n    [builtInValidationMode]\n  );\n\n  const runAllBuiltInValidation = useCallback(() => {\n    if (builtInValidationMode === false) return {};\n\n    return Object.keys(fieldsRef.current).reduce((errors, name) => {\n      const error = runBuiltInValidation(name);\n      errors = { ...errors, ...(error ? set({}, name, error) : {}) };\n      return errors;\n    }, {});\n  }, [builtInValidationMode, runBuiltInValidation]);\n\n  const runFieldValidation = useCallback(\n    async (name: string): Promise<any> => {\n      if (!fieldValidatorsRef.current[name]) return undefined;\n\n      try {\n        const error = await fieldValidatorsRef.current[name](\n          get(stateRef.current.values, name),\n          stateRef.current.values\n        );\n\n        return error;\n      } catch (exception) {\n        warn(`ðŸ’¡ react-cool-form > validate ${name}: `, exception);\n        throw exception;\n      }\n    },\n    [stateRef]\n  );\n\n  const runAllFieldsValidation = useCallback((): Promise<FormErrors<V>> => {\n    const promises = Object.keys(fieldValidatorsRef.current).map((name) =>\n      runFieldValidation(name)\n    );\n\n    return Promise.all(promises).then((errors) =>\n      Object.keys(fieldValidatorsRef.current).reduce((acc, cur, idx) => {\n        acc = { ...acc, ...(errors[idx] ? set({}, cur, errors[idx]) : {}) };\n        return acc;\n      }, {})\n    );\n  }, [runFieldValidation]);\n\n  const runFormValidation = useCallback(\n    async (name?: string): Promise<any> => {\n      if (!formValidatorRef.current) return name ? undefined : {};\n\n      try {\n        const errors = await formValidatorRef.current(stateRef.current.values);\n\n        if (name) return get(errors, name);\n\n        return isPlainObject(errors) ? errors : {};\n      } catch (exception) {\n        warn(`ðŸ’¡ react-cool-form > validate form: `, exception);\n        throw exception;\n      }\n    },\n    [formValidatorRef, stateRef]\n  );\n\n  const validateField = useCallback(\n    async (name: string) => {\n      const hasAsyncValidator =\n        isAsyncFunction(formValidatorRef.current) ||\n        isAsyncFunction(fieldValidatorsRef.current[name]);\n\n      if (hasAsyncValidator) setStateRef(\"isValidating\", true);\n\n      try {\n        const error =\n          (await runFormValidation(name)) ||\n          (await runFieldValidation(name)) ||\n          runBuiltInValidation(name);\n\n        setError(name, error);\n        if (hasAsyncValidator) setStateRef(\"isValidating\", false);\n\n        return error;\n      } catch (exception) {\n        return exception;\n      }\n    },\n    [\n      formValidatorRef,\n      runBuiltInValidation,\n      runFieldValidation,\n      runFormValidation,\n      setError,\n      setStateRef,\n    ]\n  );\n\n  const validateFieldWithLowPriority = useCallback<typeof validateField>(\n    (name) => runWithLowPriority(() => validateField(name)),\n    [validateField]\n  );\n\n  const validateForm = useCallback((): Promise<FormErrors<V>> => {\n    setStateRef(\"isValidating\", true);\n\n    return Promise.all([\n      runAllBuiltInValidation(),\n      runAllFieldsValidation(),\n      runFormValidation(),\n    ]).then((errors) => {\n      const errs = deepMerge(...errors);\n\n      setStateRef(\"errors\", errs);\n      setStateRef(\"isValidating\", false);\n\n      return errs;\n    });\n  }, [\n    runAllBuiltInValidation,\n    runAllFieldsValidation,\n    runFormValidation,\n    setStateRef,\n  ]);\n\n  const runValidation = useCallback<RunValidation>(\n    (name) => {\n      if (!name) return validateForm().then((errors) => isEmptyObject(errors));\n\n      if (Array.isArray(name))\n        return Promise.all(name.map((n) => validateField(n))).then(\n          (errors) => !compact(errors).length\n        );\n\n      return validateField(name).then((error) => !error);\n    },\n    [validateField, validateForm]\n  );\n\n  const setTouched = useCallback<SetTouched>(\n    (name, isTouched = true, shouldValidate = validateOnBlur) => {\n      if (isTouched) {\n        setStateRef(`touched.${name}`, true);\n      } else {\n        handleUnset(\n          \"touched\",\n          `touched.${name}`,\n          stateRef.current.touched,\n          name\n        );\n      }\n\n      if (shouldValidate) validateFieldWithLowPriority(name);\n    },\n    [\n      handleUnset,\n      setStateRef,\n      stateRef,\n      validateFieldWithLowPriority,\n      validateOnBlur,\n    ]\n  );\n\n  const setTouchedMaybeValidate = useCallback(\n    (name: string) =>\n      setTouched(\n        name,\n        true,\n        validateOnChange ? name !== changedFieldRef.current : undefined\n      ),\n    [setTouched, validateOnChange]\n  );\n\n  const setDirty = useCallback<SetDirty>(\n    (name, isDirty = true) => {\n      if (isDirty) {\n        setStateRef(`dirty.${name}`, true);\n      } else {\n        handleUnset(\"dirty\", `dirty.${name}`, stateRef.current.dirty, name);\n      }\n    },\n    [handleUnset, setStateRef, stateRef]\n  );\n\n  const setDirtyIfNeeded = useCallback(\n    (name: string) =>\n      setDirty(\n        name,\n        get(stateRef.current.values, name) !==\n          get(initialStateRef.current.values, name)\n      ),\n    [setDirty, stateRef]\n  );\n\n  const setValue = useCallback<SetValue>(\n    (\n      name,\n      value,\n      {\n        shouldValidate = validateOnChange,\n        shouldTouched = true,\n        shouldDirty = true,\n      } = {}\n    ) => {\n      value = isFunction(value)\n        ? value(get(stateRef.current.values, name))\n        : value;\n\n      if (!isUndefined(value)) {\n        setStateRef(`values.${name}`, value);\n      } else {\n        handleUnset(\"values\", `values.${name}`, stateRef.current.values, name);\n      }\n      setNodeValue(name, value);\n\n      if (shouldTouched) setTouched(name, true, false);\n      if (shouldDirty) setDirtyIfNeeded(name);\n      if (shouldValidate) validateFieldWithLowPriority(name);\n    },\n    [\n      handleUnset,\n      setDirtyIfNeeded,\n      setNodeValue,\n      setStateRef,\n      setTouched,\n      stateRef,\n      validateFieldWithLowPriority,\n      validateOnChange,\n    ]\n  );\n\n  const getOptions = useCallback(\n    () => ({\n      formState: stateRef.current,\n      setValue,\n      setTouched,\n      setDirty,\n      setError,\n      clearErrors,\n      runValidation,\n      reset,\n      submit,\n    }),\n    [\n      clearErrors,\n      // @ts-expect-error\n      reset,\n      runValidation,\n      setDirty,\n      setError,\n      setTouched,\n      setValue,\n      stateRef,\n      // @ts-expect-error\n      submit,\n    ]\n  );\n\n  const reset: Reset<V> = useCallback(\n    (values, exclude, e) => {\n      e?.preventDefault();\n      e?.stopPropagation();\n\n      const state = { ...stateRef.current };\n      const skip = arrayToMap(exclude || []);\n\n      Object.keys(state).forEach((key) => {\n        if (skip[key]) return;\n\n        if (key === \"values\") {\n          const nextValues =\n            (isFunction(values) ? values(stateRef.current.values) : values) ||\n            initialStateRef.current.values;\n\n          state[key] = nextValues;\n          initialStateRef.current.values = nextValues;\n          setNodesOrStateValue(initialStateRef.current.values, !!values);\n        } else {\n          // @ts-expect-error\n          state[key] = initialStateRef.current[key];\n        }\n      });\n\n      setStateRef(\"\", state);\n      onResetRef.current(state.values, getOptions(), e);\n    },\n    [getOptions, onResetRef, setNodesOrStateValue, setStateRef, stateRef]\n  );\n\n  const submit: Submit<V> = useCallback(\n    async (e) => {\n      e?.preventDefault();\n      e?.stopPropagation();\n\n      const nextTouched = Object.keys({\n        ...fieldsRef.current,\n        ...controllersRef.current,\n      }).reduce((touched, name) => {\n        touched = set(touched, name, true, true);\n        return touched;\n      }, stateRef.current.touched);\n\n      setStateRef(\"touched\", nextTouched);\n      setStateRef(\"isSubmitting\", true);\n\n      try {\n        const errors = await validateForm();\n\n        if (!isEmptyObject(errors)) {\n          onErrorRef.current(errors, getOptions(), e);\n\n          return { errors };\n        }\n\n        await onSubmitRef.current(stateRef.current.values, getOptions(), e);\n        setStateRef(\"isSubmitted\", true);\n\n        return { values: stateRef.current.values };\n      } catch (exception) {\n        warn(`ðŸ’¡ react-cool-form > submit: `, exception);\n        throw exception;\n      } finally {\n        setStateRef(\"isSubmitting\", false);\n      }\n    },\n    [getOptions, onErrorRef, onSubmitRef, setStateRef, stateRef, validateForm]\n  );\n\n  const handleChangeEvent = useCallback(\n    (name: string, value: any) => {\n      setStateRef(`values.${name}`, value);\n      setDirtyIfNeeded(name);\n\n      if (validateOnChange) validateFieldWithLowPriority(name);\n    },\n    [\n      setDirtyIfNeeded,\n      setStateRef,\n      validateFieldWithLowPriority,\n      validateOnChange,\n    ]\n  );\n\n  const controller = useCallback<Controller<V>>(\n    (\n      name,\n      {\n        validate: validator,\n        value,\n        defaultValue,\n        parse,\n        format,\n        onChange,\n        onBlur,\n      } = {}\n    ) => {\n      if (!name) {\n        warn('ðŸ’¡ react-cool-form > controller: Missing the \"name\" parameter.');\n        return undefined;\n      }\n\n      controllersRef.current[name] = true;\n      if (validator) fieldValidatorsRef.current[name] = validator;\n\n      const val = get(defaultValuesRef.current, name);\n      defaultValue = !isUndefined(val) ? val : defaultValue;\n      if (!isUndefined(defaultValue)) setDefaultValue(name, defaultValue);\n\n      value = !isUndefined(value) ? value : getState(`values.${name}`);\n      value = (format ? format(value) : value) ?? \"\";\n\n      return {\n        name,\n        value,\n        onChange: (...args) => {\n          let v;\n\n          if (parse) {\n            v = parse(...args);\n          } else {\n            const e = args[0];\n            v =\n              e?.nativeEvent instanceof Event && isFieldElement(e.target)\n                ? getNodeValue(name)\n                : e;\n          }\n\n          handleChangeEvent(name, v);\n          if (onChange) onChange(...args, v);\n          changedFieldRef.current = name;\n        },\n        onBlur: (e) => {\n          setTouchedMaybeValidate(name);\n          if (onBlur) onBlur(e);\n          changedFieldRef.current = undefined;\n        },\n      };\n    },\n    [\n      getNodeValue,\n      getState,\n      handleChangeEvent,\n      setDefaultValue,\n      setTouchedMaybeValidate,\n    ]\n  );\n\n  useIsoLayoutEffect(() => {\n    if (!formRef.current) return;\n\n    fieldsRef.current = getFields(formRef.current);\n    setNodesOrStateValue(initialStateRef.current.values, true);\n    isInitRef.current = false;\n  }, [getFields, setNodesOrStateValue]);\n\n  useEffect(() => {\n    if (!formRef.current) return () => null;\n\n    const handleChange = ({ target }: Event) => {\n      const { name } = target as FieldElement;\n\n      if (!name) {\n        warn('ðŸ’¡ react-cool-form > field: Missing the \"name\" attribute.');\n        return;\n      }\n\n      if (fieldsRef.current[name] && !controllersRef.current[name]) {\n        const parse = fieldArgsRef.current[name]?.parse;\n        const value = getNodeValue(name);\n\n        handleChangeEvent(name, parse ? parse(value) : value);\n        changedFieldRef.current = name;\n      }\n    };\n\n    const handleBlur = ({ target }: Event) => {\n      if (!isFieldElement(target as HTMLElement)) return;\n\n      const { name } = target as FieldElement;\n\n      if (fieldsRef.current[name] && !controllersRef.current[name]) {\n        setTouchedMaybeValidate(name);\n        changedFieldRef.current = undefined;\n      }\n    };\n\n    const handleSubmit = (e: Event) => submit(e as any);\n\n    const handleReset = (e: Event) => reset(null, null, e as any);\n\n    const form = formRef.current;\n    form.addEventListener(\"input\", handleChange);\n    form.addEventListener(\"focusout\", handleBlur);\n    form.addEventListener(\"submit\", handleSubmit);\n    form.addEventListener(\"reset\", handleReset);\n\n    const observer = new MutationObserver(([{ type }]) => {\n      if (type !== \"childList\") return;\n\n      const fields = getFields(form);\n      let { values } = stateRef.current;\n\n      if (shouldRemoveField)\n        Object.keys(fieldsRef.current).forEach((name) => {\n          if (fields[name]) return;\n\n          handleUnset(\n            \"values\",\n            `values.${name}`,\n            stateRef.current.values,\n            name\n          );\n          handleUnset(\n            \"touched\",\n            `touched.${name}`,\n            stateRef.current.touched,\n            name\n          );\n          handleUnset(\"dirty\", `dirty.${name}`, stateRef.current.dirty, name);\n          handleUnset(\n            \"errors\",\n            `errors.${name}`,\n            stateRef.current.errors,\n            name\n          );\n          setUsedStateRef(name, true);\n\n          initialStateRef.current.values = unset(\n            initialStateRef.current.values,\n            name,\n            true\n          );\n          delete fieldArgsRef.current[name];\n          delete fieldValidatorsRef.current[name];\n          delete controllersRef.current[name];\n        });\n\n      const addedNodes: string[] = [];\n\n      Object.keys(fields).forEach((name) => {\n        if (fieldsRef.current[name] || controllersRef.current[name]) return;\n\n        const defaultValue = get(defaultValuesRef.current, name);\n\n        if (!isUndefined(defaultValue))\n          values = set(values, name, defaultValue, true);\n\n        addedNodes.push(name);\n      });\n\n      fieldsRef.current = fields;\n      if (addedNodes.length) setNodesOrStateValue(values, true, addedNodes);\n    });\n    observer.observe(form, { childList: true, subtree: true });\n\n    return () => {\n      form.removeEventListener(\"input\", handleChange);\n      form.removeEventListener(\"focusout\", handleBlur);\n      form.removeEventListener(\"submit\", handleSubmit);\n      form.removeEventListener(\"reset\", handleReset);\n      observer.disconnect();\n    };\n  }, [\n    getFields,\n    getNodeValue,\n    handleChangeEvent,\n    handleUnset,\n    reset,\n    setNodesOrStateValue,\n    setTouchedMaybeValidate,\n    setUsedStateRef,\n    shouldRemoveField,\n    stateRef,\n    submit,\n  ]);\n\n  return {\n    form: formRef,\n    field: fieldRef,\n    getState,\n    setValue,\n    setTouched,\n    setDirty,\n    setError,\n    clearErrors,\n    runValidation,\n    reset,\n    submit,\n    controller,\n  };\n};\n","export default (element: HTMLElement): element is HTMLInputElement =>\n  element.tagName === \"INPUT\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"number\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"range\";\n","export default (callback: (args: any) => any): any =>\n  (\n    window.requestIdleCallback ||\n    ((cb) => {\n      const start = Date.now();\n      return setTimeout(\n        () =>\n          cb({\n            didTimeout: false,\n            timeRemaining: () => Math.max(0, 50 - (Date.now() - start)),\n          }),\n        1\n      );\n    })\n  )(callback, { timeout: 2000 });\n"],"names":["has","Object","prototype","hasOwnProperty","dequal","foo","bar","ctor","len","constructor","Date","getTime","RegExp","toString","Array","length","call","keys","val","ref","useRef","useEffect","current","arr","reduce","obj","key","value","FileList","cloneObject","object","Event","Error","isObject","isFileList","isArray","map","filter","Boolean","deepMerge","objects","prev","forEach","prevValue","currValue","isPlainObject","undefined","filterErrors","error","touched","nextErrors","isUndefined","str","TypeError","compact","split","path","defaultValue","stringToPath","isFunction","name","field","type","element","test","tagName","immutable","segs","newObject","slice","idx","nextIsNumber","Number","isNaN","refObject","last","pop","target","initialState","onChange","forceUpdate","useReducer","c","stateRef","usedStateRef","onChangeRef","useLatest","setStateRef","useCallback","fieldPath","shouldUpdate","get","state","set","errors","dirty","prevIsDirty","isDirty","prevIsValid","isValid","prevSubmitCount","submitCount","search","dty","found","values","push","getIsDirty","isEmptyObject","some","k","startsWith","setUsedStateRef","unset","useIsoLayoutEffect","window","useLayoutEffect","defaultValues","validate","validateOnChange","validateOnBlur","builtInValidationMode","shouldRemoveField","excludeFields","onReset","onSubmit","onError","debug","isInitRef","formRef","fieldsRef","fieldArgsRef","controllersRef","excludeFieldsRef","arrayToMap","changedFieldRef","formValidatorRef","fieldValidatorsRef","onResetRef","onSubmitRef","onErrorRef","defaultValuesRef","initialStateRef","isValidating","isSubmitting","isSubmitted","useState","getFields","form","from","querySelectorAll","rcfExclude","dataset","acc","cur","isCheckboxInput","isRadioInput","options","handleUnset","fieldRef","validateOrOptions","validator","parsers","getNodeValue","_fieldArgsRef$current","valueAsNumber","_fieldArgsRef$current2","valueAsDate","isNumberInput","isRangeInput","checkboxes","checkbox","checked","checkValues","Set","add","find","radio","isMultipleSelect","option","selected","isFileInput","files","setNodeValue","includes","setDefaultValue","setNodesOrStateValue","checkDefaultValues","fields","getState","watch","errorWithTouched","getPath","p","errorsEnhancer","replace","paths","s","setError","clearErrors","n","runBuiltInValidation","validationMessage","validity","runAllBuiltInValidation","runFieldValidation","async","exception","runAllFieldsValidation","promises","Promise","all","then","runFormValidation","validateField","hasAsyncValidator","isAsyncFunction","validateFieldWithLowPriority","callback","requestIdleCallback","cb","start","now","setTimeout","didTimeout","timeRemaining","Math","max","timeout","validateForm","errs","runValidation","setTouched","isTouched","shouldValidate","setTouchedMaybeValidate","setDirty","setDirtyIfNeeded","setValue","shouldTouched","shouldDirty","getOptions","formState","reset","submit","exclude","e","preventDefault","stopPropagation","skip","nextValues","nextTouched","handleChangeEvent","controller","parse","format","onBlur","v","args","nativeEvent","isFieldElement","handleChange","_fieldArgsRef$current3","handleBlur","handleSubmit","handleReset","addEventListener","observer","MutationObserver","addedNodes","observe","childList","subtree","removeEventListener","disconnect"],"mappings":"ueAAA,IAAIA,EAAMC,OAAOC,UAAUC,eAEpB,SAASC,EAAOC,EAAKC,GAC3B,IAAIC,EAAMC,EACV,GAAIH,IAAQC,EAAK,OAAO,EAExB,GAAID,GAAOC,IAAQC,EAAKF,EAAII,eAAiBH,EAAIG,YAAa,CAC7D,GAAIF,IAASG,KAAM,OAAOL,EAAIM,YAAcL,EAAIK,UAChD,GAAIJ,IAASK,OAAQ,OAAOP,EAAIQ,aAAeP,EAAIO,WAEnD,GAAIN,IAASO,MAAO,CACnB,IAAKN,EAAIH,EAAIU,UAAYT,EAAIS,OAC5B,KAAOP,KAASJ,EAAOC,EAAIG,GAAMF,EAAIE,MAEtC,OAAgB,IAATA,EAGR,IAAKD,GAAuB,iBAARF,EAAkB,CAErC,IAAKE,KADLC,EAAM,EACOH,EAAK,CACjB,GAAIL,EAAIgB,KAAKX,EAAKE,MAAWC,IAAQR,EAAIgB,KAAKV,EAAKC,GAAO,OAAO,EACjE,KAAMA,KAAQD,KAASF,EAAOC,EAAIE,GAAOD,EAAIC,IAAQ,OAAO,EAE7D,OAAON,OAAOgB,KAAKX,GAAKS,SAAWP,GAIrC,OAAOH,GAAQA,GAAOC,GAAQA,iBCzBZY,OACXC,EAAMC,SAAOF,UAEnBG,aAAU,WACRF,EAAIG,QAAUJ,KAGTC,cCPOI,UACdA,EAAIC,QAAO,SAACC,EAAKC,UACfD,EAAIC,IAAO,EACJD,IACN,gBCNWE,UACJ,OAAVA,GAAmC,iBAAVA,cCDXA,UAAsCA,aAAiBC,UCGjEC,EAAc,SAAdA,EAAeC,MACfA,aAAkBC,MAAO,MAAM,IAAIC,MAAM,8BAExCC,EAASH,IAAWI,EAAWJ,GAAS,OAAOA,KAEhDA,aAAkBpB,KAAM,OAAO,IAAIA,KAAKoB,EAAOnB,cAE/CG,MAAMqB,QAAQL,GAAS,OAAOA,EAAOM,KAAI,SAAClB,UAAQW,EAAYX,SAE9De,EAASH,GACX,OAAO7B,OAAOgB,KAAKa,GAAQN,QAAO,SAACC,EAA0BC,UAC3DD,EAAIC,GAAOG,EAAaC,EAA+BJ,IAChDD,IACN,UAEC,IAAIO,MAAM,uCClBFT,UAAsBA,EAAIc,OAAOC,qBCEjCX,UACbb,MAAMqB,QAAQR,MAAYA,aAAiBjB,OAASuB,EAASN,ICD1DY,EAAY,SAAZA,+BAAgBC,2BAAAA,yBACpBA,EAAQhB,QAAO,SAACiB,EAAMhB,UACpBxB,OAAOgB,KAAKQ,GAAKiB,SAAQ,SAAChB,OAClBiB,EAAYF,EAAKf,GACjBkB,EAAYnB,EAAIC,GAElBZ,MAAMqB,QAAQQ,IAAc7B,MAAMqB,QAAQS,GAC5CH,EAAKf,aAAWiB,EAAcC,GACrBC,EAAcF,IAAcE,EAAcD,GACnDH,EAAKf,GAAOa,EAAUI,EAAWC,GAEjCH,EAAKf,GAAOkB,KAITH,IACN,gBClBWd,eAAiDmB,IAAVnB,GCGjDoB,EAAe,SAAfA,EAAgBC,EAAgBC,UAC/BJ,EAAcG,GAEZ/C,OAAOgB,KAAK+B,GAAOxB,QAAO,SAACC,EAA0BC,OACpDwB,EAAaH,EAChBC,EAA8BtB,GAC9BuB,EAAgCvB,KAAQ,UAGtCyB,EAAYD,UAGRzB,EAAIC,GAFXD,EAAIC,GAAOwB,EAKNzB,IACN,IAf+BwB,EAAUD,OAAQF,cCFtCM,MACK,iBAARA,EAAkB,MAAM,IAAIC,UAAU,6BAC5CD,EAAIrC,OAEFuC,EAAQF,EAAIG,MAAM,YAFD,eCCVzB,EAAa0B,EAAcC,OACpCZ,EAAcf,KAAY0B,EAAM,OAAOC,MAEtC9B,EAAQ+B,EAAaF,GAAMhC,QAC/B,SAACC,EAAKC,UAASD,GAAO,IAAIC,KAC1BI,UAGKqB,EAAYxB,GAAS8B,EAAe9B,cCb7BA,SACG,mBAAVA,cCCOA,UACdgC,EAAWhC,IAAqC,kBAA3BA,EAAMlB,YAAYmD,iBCDzBC,SACC,aAAfA,EAAMC,iBCDQnC,UACdkB,EAAclB,KAAW1B,OAAOgB,KAAKU,GAAOZ,mBCD9BgD,SACd,wBAAwBC,KAAKD,EAAQE,qBCDvBJ,SACC,SAAfA,EAAMC,iBCDQD,SACC,oBAAfA,EAAMC,iBCDQD,SACC,UAAfA,EAAMC,iBCGNhC,EACA0B,EACA7B,EACAuC,eAAAA,IAAAA,GAAY,IAEPrB,EAAcf,GAAS,MAAM,IAAIuB,UAAU,2BAE1Cc,EAAOT,EAAaF,GACpBY,EAAYF,EAAYrC,EAAYC,GAAUA,SAEpDqC,EAAKE,MAAM,GAAI,GAAG7C,QAAO,SAACC,EAAKC,EAAK4C,OAC5BC,GAAgBC,OAAOC,MAAMD,OAAOL,EAAKG,EAAM,YACjDzB,EAAcpB,EAAIC,MAAU6C,IAChC9C,EAAIC,GAAO6C,EAAe,GAAK,IADsB9C,EAAIC,KAGxD0C,GAAWD,EAAKA,EAAKpD,OAAS,IAAM,IAAMY,EAEtCyC,cCfOtC,EAAa0B,EAAcU,eAAAA,IAAAA,GAAY,IAChDrB,EAAcf,GAAS,MAAM,IAAIuB,UAAU,2BAE1CqB,EAAYR,EAAYrC,EAAYC,GAAUA,EAC9CsC,EAAYM,KAEdN,EAAUjE,eAAeqD,iBACpBY,EAAUZ,GACVkB,MAGHP,EAAOT,EAAaF,OAErBW,EAAKpD,OAAQ,OAAO2D,MAEnBC,EAAOR,EAAKS,MACZC,EAASV,EAAK3C,QAAO,SAACC,EAAKC,UAASD,GAAO,IAAIC,KAAM0C,UAEvDnC,EAAS4C,IAAWA,EAAO1E,eAAewE,WAAcE,EAAOF,GAE5DD,cCbPI,EACAC,OAESC,EAAeC,cAAW,SAACC,UAAMA,EAAI,IAAG,MAC3CC,EAAW/D,SAAO0D,GAClBM,EAAehE,SAAY,IAC3BiE,EAAcC,EAAUP,GAAa,cAErCQ,EAAcC,eAClB,SAAChC,EAAM7B,sBAA4C,KAAnC8D,IAAAA,cAAWC,aAAAA,gBACnBhE,EAAM8B,EAAKD,MAAM,KAAK,MAEvB7B,MAWO,WAAT8B,GAA6B,WAAR9B,IACrBtB,EAAOuF,EAAIR,EAAS7D,QAASkC,GAAO7B,GACrC,KACMiE,EAAQC,EAAIV,EAAS7D,QAASkC,EAAM7B,GAAO,GAE/CmE,EAIEF,EAJFE,OACAC,EAGEH,EAHFG,MACSC,EAEPJ,EAFFK,QACSC,EACPN,EADFO,QAEiBC,EAAoBR,EAAjCS,YACAJ,EAAkB,UAARvE,EC/CL,SAACqE,WACH,SAATO,EAAUC,EAAaC,YAAAA,IAAAA,EAAe,kBACxBvG,OAAOwG,OAAOF,kBAAM,KAA3BrF,WACG,IAARA,SACFsF,EAAME,KAAKxF,GACJsF,EAGL3D,EAAc3B,IAAMoF,EAAOpF,EAAKsF,UAG/BA,EAGAF,CAAOP,GAAOhF,ODiCiB4F,CAAWZ,GAASC,EAChDG,EAAkB,WAARzE,EAAmBkF,EAAcd,GAAUI,EACrDG,EACI,iBAAR3E,GAA0BC,EACrByE,GAAmB,EACpBA,EAENjB,EAAS7D,aAAesE,GAAOK,QAAAA,EAASE,QAAAA,EAASE,YAAAA,IAEjD7C,EAAOiC,GAAajC,EAGlBkC,IACCzF,OAAOgB,KAAKmE,EAAa9D,SAASuF,MACjC,SAACC,UAAMtD,EAAKuD,WAAWD,IAAMA,EAAEC,WAAWvD,OAEzC4B,EAAa9D,QAAQ2E,SAAWA,IAAYD,GAC5CZ,EAAa9D,QAAQ6E,SAAWA,IAAYD,KAE/ClB,IACAK,EAAY/D,QAAQ6D,EAAS7D,gBAzC1BlB,EAAO+E,EAAS7D,QAASK,KAC5BwD,EAAS7D,QAAUK,EACnBqD,IACAK,EAAY/D,QAAQ6D,EAAS7D,YA0CnC,CAAC+D,IAGG2B,EAAkBxB,eACtB,SAAChC,EAAMyD,YAAAA,IAAAA,GAAQ,GACTA,SACK7B,EAAa9D,QAAQkC,GAE5B4B,EAAa9D,QAAQkC,IAAQ,IAGjC,UAGK,CAAE2B,SAAAA,EAAUI,YAAAA,EAAayB,gBAAAA,IErF5BE,EACc,oBAAXC,OAAyB9F,YAAY+F,mFCgE/B,SAXbC,cAAAA,aAAgB,KAChBC,IAAAA,aACAC,iBAAAA,oBACAC,eAAAA,oBACAC,sBAAAA,aAAwB,gBACxBC,kBAAAA,oBACAC,cAAAA,aAAgB,KAChBC,IAAAA,QACAC,IAAAA,SACAC,IAAAA,QACAC,IAAAA,MAEMC,EAAY5G,UAAO,GACnB6G,EAAU7G,SAAwB,MAClC8G,EAAY9G,SAAe,IAC3B+G,EAAe/G,SAAkB,IACjCgH,EAAiBhH,SAAY,IAC7BiH,EAAmBjH,SAAYkH,EAAWX,IAC1CY,EAAkBnH,WAClBoH,EAAmBlD,EAAUgC,GAC7BmB,EAAqBrH,SAA0C,IAC/DsH,EAAapD,EAAUsC,GAAY,cACnCe,EAAcrD,EAAUuC,GAAa,cACrCe,EAAatD,EAAUwC,GAAY,cACnCe,GAAmBzH,SAAOiG,GAC1ByB,GAAkB1H,SAAqB,CAC3CqF,OAAQoC,GAAiBvH,QACzB2B,QAAS,GACT6C,OAAQ,GACRG,SAAS,EACTF,MAAO,GACPgD,cAAc,EACd5C,SAAS,EACT6C,cAAc,EACdC,aAAa,EACb5C,YAAa,OAEoC6C,EACjDJ,GAAgBxH,QAChByG,GAFM5C,MAAAA,SAAUI,MAAAA,YAAayB,MAAAA,gBAKzBmC,GAAY3D,eAChB,SAAC4D,UACCtI,MAAMuI,KAAKD,EAAKE,iBAAiB,0BAC9BjH,QAAO,SAAC0B,OACDF,EAAQE,EAEZD,EAGED,EAHFC,KACAF,EAEEC,EAFFD,KACW2F,EACT1F,EADF2F,QAAWD,kBAGT,4BAA4BvF,KAAKF,OACjCyF,IAAe3F,KAMjBwE,EAAe9G,QAAQsC,MACrB2F,GAAclB,EAAiB/G,QAAQsC,SAG5CpC,QAAO,SAACiI,EAA0BC,OAC3B7F,EAAQ6F,EACN9F,EAASC,EAATD,YAER6F,EAAI7F,QAAa6F,EAAI7F,IAAOC,MAAO6F,KAE/BC,EAAgB9F,IAAU+F,EAAa/F,MACzC4F,EAAI7F,GAAMiG,QAAUJ,EAAI7F,GAAMiG,kBACtBJ,EAAI7F,GAAMiG,SAASH,IACvB,CAACA,IAEAD,IACN,MACP,IAGIK,GAActE,eAClB,SAAChC,EAAciC,EAAmBZ,EAAajB,UAC7C2B,GAAY/B,EAAMyD,EAAMpC,EAAQjB,GAAM,GAAO,CAAE6B,UAAAA,MACjD,CAACF,KAGGwE,GAAWvE,eACf,SAACwE,UAAsB,SAACnG,YAEnBA,GAAAA,EAAOD,OACRwE,EAAe9G,QAAQuC,EAAMD,QAC7ByE,EAAiB/G,QAAQuC,EAAMD,SAI7BD,EAAWqG,GACbvB,EAAmBnH,QAAQuC,EAAMD,MAAQoG,WAIzBC,EAA0BD,EAApC1C,SAAwB4C,uIAAYF,gBAExCC,IAAWxB,EAAmBnH,QAAQuC,EAAMD,MAAQqG,GACxD9B,EAAa7G,QAAQuC,EAAMD,MAAQsG,MAErC,IAGIC,GAAe3E,eACnB,SAAC5B,WAC4BsE,EAAU5G,QAAQsC,GAArCC,IAAAA,MAAOgG,IAAAA,QACXlI,EAAQkC,EAAMlC,SCtKF,UDwKGkC,ECxKfI,QDwKuB,qBACrBkE,EAAa7G,QAAQsC,KAArBwG,EAA4BC,qBAC9B1I,EAAQkC,EAAMwG,0BAGZlC,EAAa7G,QAAQsC,KAArB0G,EAA4BC,mBAC9B5I,EAAQkC,EAAM0G,yBE7KR1G,SACC,WAAfA,EAAMC,KFiLE0G,CAAc3G,aGlLRA,SACC,UAAfA,EAAMC,KHiL0B2G,CAAa5G,MACvClC,EAAQkC,EAAMwG,eAAiB,IAE7BV,EAAgB9F,MACdgG,EAAS,KACLa,EAAab,EAGjBlI,EADEkI,EAAQ9I,OAAS,EACX2J,EACLrI,QAAO,SAACsI,UAAaA,EAASC,WAC9BxI,KAAI,SAACuI,UAAaA,EAAShJ,SAEtB+I,EAAW,GAAGE,YAEnB,KACDC,EAAclF,EAAIR,GAAS7D,QAAQmF,OAAQ5C,EAAMD,MAEjD9C,MAAMqB,QAAQ0I,IAChBA,EAAc,IAAIC,IAAID,GAElBhH,EAAM+G,QACRC,EAAYE,IAAIpJ,GAEhBkJ,SAAmBlJ,GAGrBA,EAAQb,MAAMuI,KAAKwB,IAEnBlJ,EAAQkC,EAAM+G,eAKhBhB,EAAa/F,IAAUgG,IACzBlI,YACGkI,EAA+BmB,MAAK,SAACC,UAAUA,EAAML,qBAClDjJ,QAAS,IAEbuJ,EAAiBrH,KAAWgG,IAC9BlI,EAAQb,MAAMuI,KAAKxF,EAAMgG,SACtBxH,QAAO,SAAC8I,UAAWA,EAAOC,YAC1BhJ,KAAI,SAAC+I,UAAWA,EAAOxJ,UAExB0J,EAAYxH,KAAQlC,EAAQkC,EAAMyH,OAE/B3J,IAET,CAACwD,KAGGoG,GAAe/F,eAAY,SAAC5B,EAAcjC,MACzCuG,EAAU5G,QAAQsC,KAASwE,EAAe9G,QAAQsC,UAE5BsE,EAAU5G,QAAQsC,GAArCC,IAAAA,MAAOgG,IAAAA,WAEXF,EAAgB9F,GAAQ,KACpB6G,EAAab,EAEfa,EAAW3J,OAAS,EACtB2J,EAAWhI,SAAQ,SAACiI,GAClBA,EAASC,QAAU9J,MAAMqB,QAAQR,GAC7BA,EAAM6J,SAASb,EAAShJ,SACtBA,KAGR+I,EAAW,GAAGE,UAAYjJ,OAEnBiI,EAAa/F,GACrBgG,EAA+BnH,SAAQ,SAACuI,GACvCA,EAAML,QAAUK,EAAMtJ,QAAUA,KAEzBuJ,EAAiBrH,IAAU/C,MAAMqB,QAAQR,GAClDb,MAAMuI,KAAKxF,EAAMgG,SAASnH,SAAQ,SAACyI,GACjCA,EAAOC,WAAazJ,EAAM6J,SAASL,EAAOxJ,UAEnC0J,EAAYxH,IACjB3B,EAAWP,KAAQkC,EAAMyH,MAAQ3J,GAChCA,IAAOkC,EAAMlC,MAAQ,KAE1BkC,EAAMlC,YAAQA,EAAAA,EAAS,MAExB,IAEG8J,GAAkBjG,eACtB,SAAC5B,EAAcjC,GACRwB,EAAYwC,EAAImD,GAAgBxH,QAAQmF,OAAQ7C,MAErDkF,GAAgBxH,QAAQmF,OAASZ,EAC/BiD,GAAgBxH,QAAQmF,OACxB7C,EACAjC,GACA,GAGF4D,aAAsB3B,EAAQ+B,EAAImD,GAAgBxH,QAAQmF,OAAQ7C,GAAO,CACvE8B,cAAesC,EAAU1G,aAG7B,CAACiE,KAGGmG,GAAuBlG,eAC3B,SACEiB,EACAkF,EACAC,mBADAD,IAAAA,GAAqB,YACrBC,IAAAA,EAAmC3L,OAAOwG,OAAOyB,EAAU5G,UAE3DsK,EAAOlJ,SAAQ,SAACmB,OACRD,EAAOf,EAAcgB,GACtBA,EAAsBA,MAAMD,KAC7BC,MAEAuE,EAAe9G,QAAQsC,QAErBjC,EAAQgE,EAAIc,EAAQ7C,MAErBT,EAAYxB,IAAQ4J,GAAa3H,EAAMjC,GAExCgK,EAAoB,KAChBlI,EAAekC,EAAIkD,GAAiBvH,QAASsC,GAEnD6H,GACE7H,EACCT,EAAYM,GAA+B0G,GAAavG,GAA5BH,UAIrC,CAAC0G,GAAcsB,GAAiBF,KAG5BM,GAAWrG,eACf,SAAChC,sBAA2D,KAAnDqB,IAAAA,WAAQiH,MAAAA,oBAAcC,iBAAAA,mBACxBvI,OA6BDoC,EA3BEoG,EAAU,SAACC,UAMfA,EAAIpH,EAAYA,MAAUoH,EAAMA,EAE5BH,GAAO9E,GAAgBiF,GAEpBA,GAEHC,EAAiB,SAACD,EAAWrG,UAE9BkG,GACAC,GACAE,EAAElF,WAAW,WACbnB,IACDgB,EAAchB,IAIhBqG,EAAIA,EAAEE,QAAQ,SAAU,WACxBnF,GAAgBiF,GAETlJ,EAAa6C,EAAOD,EAAIR,GAAS7D,QAAS2K,KALxCrG,MASP9E,MAAMqB,QAAQqB,GAChBoC,EAAQpC,EAAKpB,KAAI,SAAC6J,UAChBA,EAAID,EAAQC,GACLC,EAAeD,EAAGtG,EAAIR,GAAS7D,QAAS2K,YAE5C,GAAIpJ,EAAcW,GAAO,KACxB4I,EAAQ5I,EACdoC,EAAQ3F,OAAOgB,KAAKmL,GAAO5K,QAAO,SAAC6K,EAAwB3K,UACzD8B,EAAOwI,EAAQI,EAAM1K,IACrB2K,EAAE3K,GAAOwK,EAAe1I,EAAMmC,EAAIR,GAAS7D,QAASkC,IAC7C6I,IACN,SAEH7I,EAAOwI,EAAQxI,GACfoC,EAAQsG,EAAe1I,EAAMmC,EAAIR,GAAS7D,QAASkC,WAG9CoC,KAET,CAACoB,GAAiB7B,KAGdmH,GAAW9G,eACf,SAAC5B,EAAMZ,IACLA,EAAQW,EAAWX,GACfA,EAAM2C,EAAIR,GAAS7D,QAAQwE,OAAQlC,IACnCZ,GAGFuC,aAAsB3B,EAAQZ,GAE9B8G,GAAY,mBAAoBlG,EAAQuB,GAAS7D,QAAQwE,OAAQlC,KAGrE,CAACkG,GAAavE,GAAaJ,KAGvBoH,GAAc/G,eAClB,SAAC5B,GACMA,EAEM9C,MAAMqB,QAAQyB,GACvBA,EAAKlB,SAAQ,SAAC8J,UACZ1C,GAAY,mBAAoB0C,EAAKrH,GAAS7D,QAAQwE,OAAQ0G,MAGhE1C,GAAY,mBAAoBlG,EAAQuB,GAAS7D,QAAQwE,OAAQlC,GANjE2B,GAAY,SAAU,MAS1B,CAACuE,GAAavE,GAAaJ,KAGvBsH,GAAuBjH,eAC3B,SAAC5B,OAC+B,IAA1B6D,GAAoCS,EAAU5G,QAAQsC,QAGlDC,EAAUqE,EAAU5G,QAAQsC,GAA5BC,SAEsB,YAA1B4D,EAAqC,OAAO5D,EAAM6I,sBAEjD,IAAM5F,KAAKjD,EAAM8I,YAEV,UAAN7F,GAAiBjD,EAAM8I,SAAS7F,GAAI,OAAOA,KAKnD,CAACW,IAGGmF,GAA0BpH,eAAY,kBACZ,IAA1BiC,EAAwC,GAErCxH,OAAOgB,KAAKiH,EAAU5G,SAASE,QAAO,SAACsE,EAAQlC,OAC9CZ,EAAQyJ,GAAqB7I,UACnCkC,OAAcA,EAAY9C,EAAQ6C,EAAI,GAAIjC,EAAMZ,GAAS,MAExD,MACF,CAACyE,EAAuBgF,KAErBI,GAAqBrH,eACzBsH,eAAOlJ,MACA6E,EAAmBnH,QAAQsC,oBAGV6E,EAAmBnH,QAAQsC,GAC7C+B,EAAIR,GAAS7D,QAAQmF,OAAQ7C,GAC7BuB,GAAS7D,QAAQmF,QAInB,MAAOsG,SAEDA,KAGV,CAAC5H,KAGG6H,GAAyBxH,eAAY,eACnCyH,EAAWhN,OAAOgB,KAAKwH,EAAmBnH,SAASc,KAAI,SAACwB,UAC5DiJ,GAAmBjJ,aAGdsJ,QAAQC,IAAIF,GAAUG,MAAK,SAACtH,UACjC7F,OAAOgB,KAAKwH,EAAmBnH,SAASE,QAAO,SAACiI,EAAKC,EAAKpF,UACxDmF,OAAWA,EAAS3D,EAAOxB,GAAOuB,EAAI,GAAI6D,EAAK5D,EAAOxB,IAAQ,MAE7D,SAEJ,CAACuI,KAEEQ,GAAoB7H,eACxBsH,eAAOlJ,OACA4E,EAAiBlH,QAAS,OAAOsC,OAAOd,EAAY,WAGjDgD,QAAe0C,EAAiBlH,QAAQ6D,GAAS7D,QAAQmF,eAE3D7C,EAAa+B,EAAIG,EAAQlC,GAEtBf,EAAciD,GAAUA,EAAS,GACxC,MAAOiH,SAEDA,KAGV,CAACvE,EAAkBrD,KAGfmI,GAAgB9H,eACpBsH,eAAOlJ,OACC2J,EACJC,EAAgBhF,EAAiBlH,UACjCkM,EAAgB/E,EAAmBnH,QAAQsC,IAEzC2J,GAAmBhI,GAAY,gBAAgB,WAG3CvC,QACGqK,GAAkBzJ,UAClBiJ,GAAmBjJ,IAC1B6I,GAAqB7I,UAEvB0I,GAAS1I,EAAMZ,GACXuK,GAAmBhI,GAAY,gBAAgB,GAE5CvC,EACP,MAAO+J,UACAA,KAGX,CACEvE,EACAiE,GACAI,GACAQ,GACAf,GACA/G,KAIEkI,GAA+BjI,eACnC,SAAC5B,UI3fW8J,EJ2fiB,kBAAMJ,GAAc1J,KIzfjDuD,OAAOwG,qBACN,SAACC,OACMC,EAAQnN,KAAKoN,aACZC,YACL,kBACEH,EAAG,CACDI,YAAY,EACZC,cAAe,kBAAMC,KAAKC,IAAI,EAAG,IAAMzN,KAAKoN,MAAQD,SAExD,KAGJH,EAAU,CAAEU,QAAS,UAdTV,IJ4fZ,CAACJ,KAGGe,GAAe7I,eAAY,kBAC/BD,GAAY,gBAAgB,GAErB2H,QAAQC,IAAI,CACjBP,KACAI,KACAK,OACCD,MAAK,SAACtH,OACDwI,EAAO/L,eAAauD,UAE1BP,GAAY,SAAU+I,GACtB/I,GAAY,gBAAgB,GAErB+I,OAER,CACD1B,GACAI,GACAK,GACA9H,KAGIgJ,GAAgB/I,eACpB,SAAC5B,UACMA,EAED9C,MAAMqB,QAAQyB,GACTsJ,QAAQC,IAAIvJ,EAAKxB,KAAI,SAACoK,UAAMc,GAAcd,OAAKY,MACpD,SAACtH,UAAYxC,EAAQwC,GAAQ/E,UAG1BuM,GAAc1J,GAAMwJ,MAAK,SAACpK,UAAWA,KAP1BqL,KAAejB,MAAK,SAACtH,UAAWc,EAAcd,QASlE,CAACwH,GAAee,KAGZG,GAAahJ,eACjB,SAAC5B,EAAM6K,EAAkBC,YAAlBD,IAAAA,GAAY,YAAMC,IAAAA,EAAiBlH,GACpCiH,EACFlJ,cAAuB3B,GAAQ,GAE/BkG,GACE,qBACWlG,EACXuB,GAAS7D,QAAQ2B,QACjBW,GAIA8K,GAAgBjB,GAA6B7J,KAEnD,CACEkG,GACAvE,GACAJ,GACAsI,GACAjG,IAIEmH,GAA0BnJ,eAC9B,SAAC5B,UACC4K,GACE5K,GACA,EACA2D,EAAmB3D,IAAS2E,EAAgBjH,aAAUwB,KAE1D,CAAC0L,GAAYjH,IAGTqH,GAAWpJ,eACf,SAAC5B,EAAMqC,YAAAA,IAAAA,GAAU,GACXA,EACFV,YAAqB3B,GAAQ,GAE7BkG,GAAY,iBAAkBlG,EAAQuB,GAAS7D,QAAQyE,MAAOnC,KAGlE,CAACkG,GAAavE,GAAaJ,KAGvB0J,GAAmBrJ,eACvB,SAAC5B,UACCgL,GACEhL,EACA+B,EAAIR,GAAS7D,QAAQmF,OAAQ7C,KAC3B+B,EAAImD,GAAgBxH,QAAQmF,OAAQ7C,MAE1C,CAACgL,GAAUzJ,KAGP2J,GAAWtJ,eACf,SACE5B,EACAjC,sBAKI,SAHF+M,eAAAA,aAAiBnH,QACjBwH,cAAAA,oBACAC,YAAAA,gBAGFrN,EAAQgC,EAAWhC,GACfA,EAAMgE,EAAIR,GAAS7D,QAAQmF,OAAQ7C,IACnCjC,EAECwB,EAAYxB,GAGfmI,GAAY,mBAAoBlG,EAAQuB,GAAS7D,QAAQmF,OAAQ7C,GAFjE2B,aAAsB3B,EAAQjC,GAIhC4J,GAAa3H,EAAMjC,GAEfoN,GAAeP,GAAW5K,GAAM,GAAM,GACtCoL,GAAaH,GAAiBjL,GAC9B8K,GAAgBjB,GAA6B7J,KAEnD,CACEkG,GACA+E,GACAtD,GACAhG,GACAiJ,GACArJ,GACAsI,GACAlG,IAIE0H,GAAazJ,eACjB,iBAAO,CACL0J,UAAW/J,GAAS7D,QACpBwN,SAAAA,GACAN,WAAAA,GACAI,SAAAA,GACAtC,SAAAA,GACAC,YAAAA,GACAgC,cAAAA,GACAY,MAAAA,GACAC,OAAAA,MAEF,CACE7C,GAEA4C,GACAZ,GACAK,GACAtC,GACAkC,GACAM,GACA3J,GAEAiK,KAIED,GAAkB3J,eACtB,SAACiB,EAAQ4I,EAASC,SAChBA,GAAAA,EAAGC,uBACHD,GAAAA,EAAGE,sBAEG5J,OAAaT,GAAS7D,SACtBmO,EAAOnH,EAAW+G,GAAW,IAEnCpP,OAAOgB,KAAK2E,GAAOlD,SAAQ,SAAChB,OACtB+N,EAAK/N,MAEG,WAARA,EAAkB,KACdgO,GACH/L,EAAW8C,GAAUA,EAAOtB,GAAS7D,QAAQmF,QAAUA,IACxDqC,GAAgBxH,QAAQmF,OAE1Bb,EAAMlE,GAAOgO,EACb5G,GAAgBxH,QAAQmF,OAASiJ,EACjChE,GAAqB5C,GAAgBxH,QAAQmF,SAAUA,QAGvDb,EAAMlE,GAAOoH,GAAgBxH,QAAQI,MAIzC6D,GAAY,GAAIK,GAChB8C,EAAWpH,QAAQsE,EAAMa,OAAQwI,KAAcK,KAEjD,CAACL,GAAYvG,EAAYgD,GAAsBnG,GAAaJ,KAGxDiK,GAAoB5J,eACxBsH,eAAOwC,SACLA,GAAAA,EAAGC,uBACHD,GAAAA,EAAGE,sBAEGG,EAAc1P,OAAOgB,UACtBiH,EAAU5G,QACV8G,EAAe9G,UACjBE,QAAO,SAACyB,EAASW,UAClBX,EAAU4C,EAAI5C,EAASW,GAAM,GAAM,KAElCuB,GAAS7D,QAAQ2B,SAEpBsC,GAAY,UAAWoK,GACvBpK,GAAY,gBAAgB,WAGpBO,QAAeuI,YAEhBzH,EAAcd,UAMb6C,EAAYrH,QAAQ6D,GAAS7D,QAAQmF,OAAQwI,KAAcK,GACjE/J,GAAY,eAAe,GAEpB,CAAEkB,OAAQtB,GAAS7D,QAAQmF,UARhCmC,EAAWtH,QAAQwE,EAAQmJ,KAAcK,GAElC,CAAExJ,OAAAA,IAOX,MAAOiH,SAEDA,UAENxH,GAAY,gBAAgB,MAGhC,CAAC0J,GAAYrG,EAAYD,EAAapD,GAAaJ,GAAUkJ,KAGzDuB,GAAoBpK,eACxB,SAAC5B,EAAcjC,GACb4D,aAAsB3B,EAAQjC,GAC9BkN,GAAiBjL,GAEb2D,GAAkBkG,GAA6B7J,KAErD,CACEiL,GACAtJ,GACAkI,GACAlG,IAIEsI,GAAarK,eACjB,SACE5B,wBASI,KAPQqG,IAAV3C,SACA3F,IAAAA,MACA8B,IAAAA,aACAqM,IAAAA,MACAC,IAAAA,OACAhL,IAAAA,SACAiL,IAAAA,UAGGpM,GAKLwE,EAAe9G,QAAQsC,IAAQ,EAC3BqG,IAAWxB,EAAmBnH,QAAQsC,GAAQqG,OAE5C/I,EAAMyE,EAAIkD,GAAiBvH,QAASsC,UAC1CH,EAAgBN,EAAYjC,GAAauC,EAANvC,EAC9BiC,EAAYM,IAAegI,GAAgB7H,EAAMH,GAEtD9B,EAASwB,EAAYxB,GAAiBkK,aAAmBjI,GAA3BjC,EAC9BA,WAASoO,EAASA,EAAOpO,GAASA,KAAU,GAErC,CACLiC,KAAAA,EACAjC,MAAAA,EACAoD,SAAU,mBACJkL,qBADQC,2BAAAA,qBAGRJ,EACFG,EAAIH,eAASI,OACR,KACCZ,EAAIY,EAAK,GACfD,SACEX,SAAAA,EAAGa,uBAAuBpO,OAASqO,EAAed,EAAEzK,QAChDsF,GAAavG,GACb0L,EAGRM,GAAkBhM,EAAMqM,GACpBlL,GAAUA,eAAYmL,UAAMD,KAChC1H,EAAgBjH,QAAUsC,GAE5BoM,OAAQ,SAACV,GACPX,GAAwB/K,GACpBoM,GAAQA,EAAOV,GACnB/G,EAAgBjH,aAAUwB,OAIhC,CACEqH,GACA0B,GACA+D,GACAnE,GACAkD,YAIJzH,GAAmB,WACZe,EAAQ3G,UAEb4G,EAAU5G,QAAU6H,GAAUlB,EAAQ3G,SACtCoK,GAAqB5C,GAAgBxH,QAAQmF,QAAQ,GACrDuB,EAAU1G,SAAU,KACnB,CAAC6H,GAAWuC,KAEfrK,aAAU,eACH4G,EAAQ3G,QAAS,OAAO,kBAAM,UAE7B+O,EAAe,gBACXzM,IADciB,OACdjB,QAEHA,GAKDsE,EAAU5G,QAAQsC,KAAUwE,EAAe9G,QAAQsC,GAAO,OACtDkM,WAAQ3H,EAAa7G,QAAQsC,WAArB0M,EAA4BR,MACpCnO,EAAQwI,GAAavG,GAE3BgM,GAAkBhM,EAAMkM,EAAQA,EAAMnO,GAASA,GAC/C4G,EAAgBjH,QAAUsC,IAIxB2M,EAAa,gBAAG1L,IAAAA,UACfuL,EAAevL,QAEZjB,EAASiB,EAATjB,KAEJsE,EAAU5G,QAAQsC,KAAUwE,EAAe9G,QAAQsC,KACrD+K,GAAwB/K,GACxB2E,EAAgBjH,aAAUwB,KAIxB0N,EAAe,SAAClB,UAAaF,GAAOE,IAEpCmB,EAAc,SAACnB,UAAaH,GAAM,KAAM,KAAMG,IAE9ClG,EAAOnB,EAAQ3G,QACrB8H,EAAKsH,iBAAiB,QAASL,GAC/BjH,EAAKsH,iBAAiB,WAAYH,GAClCnH,EAAKsH,iBAAiB,SAAUF,GAChCpH,EAAKsH,iBAAiB,QAASD,OAEzBE,EAAW,IAAIC,kBAAiB,eACvB,mBAD2B9M,UAGlC8H,EAASzC,GAAUC,GACnB3C,EAAWtB,GAAS7D,QAApBmF,OAEFiB,GACFzH,OAAOgB,KAAKiH,EAAU5G,SAASoB,SAAQ,SAACkB,GAClCgI,EAAOhI,KAEXkG,GACE,mBACUlG,EACVuB,GAAS7D,QAAQmF,OACjB7C,GAEFkG,GACE,qBACWlG,EACXuB,GAAS7D,QAAQ2B,QACjBW,GAEFkG,GAAY,iBAAkBlG,EAAQuB,GAAS7D,QAAQyE,MAAOnC,GAC9DkG,GACE,mBACUlG,EACVuB,GAAS7D,QAAQwE,OACjBlC,GAEFoD,GAAgBpD,GAAM,GAEtBkF,GAAgBxH,QAAQmF,OAASQ,EAC/B6B,GAAgBxH,QAAQmF,OACxB7C,GACA,UAEKuE,EAAa7G,QAAQsC,UACrB6E,EAAmBnH,QAAQsC,UAC3BwE,EAAe9G,QAAQsC,WAG5BiN,EAAuB,GAE7B5Q,OAAOgB,KAAK2K,GAAQlJ,SAAQ,SAACkB,OACvBsE,EAAU5G,QAAQsC,KAASwE,EAAe9G,QAAQsC,QAEhDH,EAAekC,EAAIkD,GAAiBvH,QAASsC,GAE9CT,EAAYM,KACfgD,EAASZ,EAAIY,EAAQ7C,EAAMH,GAAc,IAE3CoN,EAAWnK,KAAK9C,OAGlBsE,EAAU5G,QAAUsK,EAChBiF,EAAW9P,QAAQ2K,GAAqBjF,GAAQ,EAAMoK,cAE5DF,EAASG,QAAQ1H,EAAM,CAAE2H,WAAW,EAAMC,SAAS,IAE5C,WACL5H,EAAK6H,oBAAoB,QAASZ,GAClCjH,EAAK6H,oBAAoB,WAAYV,GACrCnH,EAAK6H,oBAAoB,SAAUT,GACnCpH,EAAK6H,oBAAoB,QAASR,GAClCE,EAASO,gBAEV,CACD/H,GACAgB,GACAyF,GACA9F,GACAqF,GACAzD,GACAiD,GACA3H,GACAU,EACAvC,GACAiK,KAGK,CACLhG,KAAMnB,EACNpE,MAAOkG,GACP8B,SAAAA,GACAiD,SAAAA,GACAN,WAAAA,GACAI,SAAAA,GACAtC,SAAAA,GACAC,YAAAA,GACAgC,cAAAA,GACAY,MAAAA,GACAC,OAAAA,GACAS,WAAAA"}