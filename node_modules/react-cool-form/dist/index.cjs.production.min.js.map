{"version":3,"file":"index.cjs.production.min.js","sources":["../src/hooks/useLatest.ts","../src/utils/arrayToMap.ts","../src/utils/isObject.ts","../src/utils/isFileList.ts","../src/utils/cloneObject.ts","../src/utils/compact.ts","../src/utils/isPlainObject.ts","../src/utils/deepMerge.ts","../src/utils/isUndefined.ts","../src/utils/filterErrors.ts","../src/utils/stringToPath.ts","../src/utils/get.ts","../src/utils/isFunction.ts","../src/utils/isAsyncFunction.ts","../src/utils/isCheckboxInput.ts","../src/utils/isEmptyObject.ts","../src/utils/isFieldElement.ts","../src/utils/isFileInput.ts","../src/utils/isMultipleSelect.ts","../src/utils/isRadioInput.ts","../src/utils/set.ts","../src/utils/unset.ts","../src/hooks/useState.ts","../src/utils/getIsDirty.ts","../src/hooks/useIsoLayoutEffect.ts","../src/useForm.ts","../src/utils/isInputElement.ts","../src/utils/isNumberInput.ts","../src/utils/isRangeInput.ts","../src/utils/runWithLowPriority.ts"],"sourcesContent":["import { MutableRefObject, useRef, useEffect } from \"react\";\n\nexport default <T>(val: T): MutableRefObject<T> => {\n  const ref = useRef(val);\n\n  useEffect(() => {\n    ref.current = val;\n  });\n\n  return ref;\n};\n","import { Map } from \"../types\";\n\nexport default (arr: any[]): Map =>\n  arr.reduce((obj, key) => {\n    obj[key] = true;\n    return obj;\n  }, {});\n","export default (value: unknown): value is Object =>\n  value !== null && typeof value === \"object\";\n","export default (value: unknown): value is FileList => value instanceof FileList;\n","import isObject from \"./isObject\";\nimport isFileList from \"./isFileList\";\n\nconst cloneObject = (object: unknown): any => {\n  if (object instanceof Event) throw new Error(\"Unable to clone event.\");\n\n  if (!isObject(object) || isFileList(object)) return object;\n\n  if (object instanceof Date) return new Date(object.getTime());\n\n  if (Array.isArray(object)) return object.map((val) => cloneObject(val));\n\n  if (isObject(object))\n    return Object.keys(object).reduce((obj: Record<string, any>, key) => {\n      obj[key] = cloneObject((object as Record<string, any>)[key]);\n      return obj;\n    }, {});\n\n  throw new Error(\"Unable to clone object.\");\n};\n\nexport default cloneObject;\n","export default (arr: any[]): any[] => arr.filter(Boolean);\n","import isObject from \"./isObject\";\n\nexport default (value: unknown): value is Object =>\n  !Array.isArray(value) && !(value instanceof Date) && isObject(value);\n","import isPlainObject from \"./isPlainObject\";\n\nconst deepMerge = (...objects: any[]): any =>\n  objects.reduce((prev, obj) => {\n    Object.keys(obj).forEach((key) => {\n      const prevValue = prev[key];\n      const currValue = obj[key];\n\n      if (Array.isArray(prevValue) && Array.isArray(currValue)) {\n        prev[key] = [...prevValue, ...currValue];\n      } else if (isPlainObject(prevValue) && isPlainObject(currValue)) {\n        prev[key] = deepMerge(prevValue, currValue);\n      } else {\n        prev[key] = currValue;\n      }\n    });\n\n    return prev;\n  }, {});\n\nexport default deepMerge;\n","export default (value: unknown): value is undefined => value === undefined;\n","import isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\n\nconst filterErrors = (error: unknown, touched: unknown): any => {\n  if (!isPlainObject(error)) return touched ? error : undefined;\n\n  return Object.keys(error).reduce((obj: Record<string, any>, key) => {\n    const nextErrors = filterErrors(\n      (error as Record<string, any>)[key],\n      (touched as Record<string, any>)[key] || false\n    );\n\n    if (!isUndefined(nextErrors)) {\n      obj[key] = nextErrors;\n    } else {\n      delete obj[key];\n    }\n\n    return obj;\n  }, {});\n};\n\nexport default filterErrors;\n","import compact from \"./compact\";\n\nexport default (str: string): string[] => {\n  if (typeof str !== \"string\") throw new TypeError(\"Expected a string.\");\n  if (!str.length) return [];\n\n  return compact(str.split(/[.[\\]]+/));\n};\n","import isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\nimport stringToPath from \"./stringToPath\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport default (object: any, path: string, defaultValue?: unknown): any => {\n  if (!isPlainObject(object) || !path) return defaultValue;\n\n  const value = stringToPath(path).reduce(\n    (obj, key) => (obj || {})[key],\n    object\n  );\n\n  return isUndefined(value) ? defaultValue : value;\n};\n","export default (value: unknown): value is Function =>\n  typeof value === \"function\";\n","import isFunction from \"./isFunction\";\n\nexport default (value: unknown): value is Promise<any> =>\n  isFunction(value) && value.constructor.name === \"AsyncFunction\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"checkbox\";\n","import isPlainObject from \"./isPlainObject\";\n\nexport default (value: unknown): value is Record<string, never> =>\n  isPlainObject(value) && !Object.keys(value).length;\n","import { FieldElement } from \"../types\";\n\nexport default (element: HTMLElement): element is FieldElement =>\n  /INPUT|TEXTAREA|SELECT/.test(element.tagName);\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"file\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLSelectElement =>\n  field.type === \"select-multiple\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"radio\";\n","import cloneObject from \"./cloneObject\";\nimport isPlainObject from \"./isPlainObject\";\nimport stringToPath from \"./stringToPath\";\n\nexport default (\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  object: any,\n  path: string,\n  value: unknown,\n  immutable = false\n): any => {\n  if (!isPlainObject(object)) throw new TypeError(\"Expected an object.\");\n\n  const segs = stringToPath(path);\n  const newObject = immutable ? cloneObject(object) : object;\n\n  segs.slice(0, -1).reduce((obj, key, idx) => {\n    const nextIsNumber = !Number.isNaN(Number(segs[idx + 1]));\n    if (isPlainObject(obj[key]) && !nextIsNumber) return obj[key];\n    obj[key] = nextIsNumber ? [] : {};\n    return obj[key];\n  }, newObject)[segs[segs.length - 1] || \"\"] = value;\n\n  return newObject;\n};\n","/* eslint-disable no-prototype-builtins */\n\nimport cloneObject from \"./cloneObject\";\nimport isPlainObject from \"./isPlainObject\";\nimport isObject from \"./isObject\";\nimport stringToPath from \"./stringToPath\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport default (object: any, path: string, immutable = false): any => {\n  if (!isPlainObject(object)) throw new TypeError(\"Expected an object.\");\n\n  const refObject = immutable ? cloneObject(object) : object;\n  const newObject = refObject;\n\n  if (newObject.hasOwnProperty(path)) {\n    delete newObject[path];\n    return refObject;\n  }\n\n  const segs = stringToPath(path);\n\n  if (!segs.length) return refObject;\n\n  const last = segs.pop() as string;\n  const target = segs.reduce((obj, key) => (obj || {})[key], newObject);\n\n  if (isObject(target) && target.hasOwnProperty(last)) delete target[last];\n\n  return refObject;\n};\n","import { useReducer, useRef, useCallback } from \"react\";\nimport { dequal } from \"dequal/lite\";\n\nimport {\n  Debug,\n  FormState,\n  FormStateReturn,\n  Map,\n  SetStateRef,\n  SetUsedStateRef,\n} from \"../types\";\nimport useLatest from \"./useLatest\";\nimport { get, getIsDirty, isEmptyObject, set } from \"../utils\";\n\nexport default <V>(\n  initialState: FormState<V>,\n  onChange?: Debug<V>\n): FormStateReturn<V> => {\n  const [, forceUpdate] = useReducer((c) => c + 1, 0);\n  const stateRef = useRef(initialState);\n  const usedStateRef = useRef<Map>({});\n  const onChangeRef = useLatest(onChange || (() => undefined));\n\n  const setStateRef = useCallback<SetStateRef>(\n    (path, value, { fieldPath, shouldUpdate = true } = {}) => {\n      const key = path.split(\".\")[0];\n\n      if (!key) {\n        if (!dequal(stateRef.current, value)) {\n          stateRef.current = value;\n          forceUpdate();\n          onChangeRef.current(stateRef.current);\n        }\n\n        return;\n      }\n\n      if (\n        (path !== \"values\" && key === \"values\") ||\n        !dequal(get(stateRef.current, path), value)\n      ) {\n        const state = set(stateRef.current, path, value, true);\n        const {\n          errors,\n          dirty,\n          isDirty: prevIsDirty,\n          isValid: prevIsValid,\n        } = state;\n        let { submitCount: prevSubmitCount } = state;\n        const isDirty = key === \"dirty\" ? getIsDirty(dirty) : prevIsDirty;\n        const isValid = key === \"errors\" ? isEmptyObject(errors) : prevIsValid;\n        const submitCount =\n          key === \"isSubmitting\" && value\n            ? (prevSubmitCount += 1)\n            : prevSubmitCount;\n\n        stateRef.current = { ...state, isDirty, isValid, submitCount };\n\n        path = fieldPath || path;\n\n        if (\n          shouldUpdate &&\n          (Object.keys(usedStateRef.current).some(\n            (k) => path.startsWith(k) || k.startsWith(path)\n          ) ||\n            (usedStateRef.current.isDirty && isDirty !== prevIsDirty) ||\n            (usedStateRef.current.isValid && isValid !== prevIsValid))\n        ) {\n          forceUpdate();\n          onChangeRef.current(stateRef.current);\n        }\n      }\n    },\n    [onChangeRef]\n  );\n\n  const setUsedStateRef = useCallback<SetUsedStateRef>(\n    (path, unset = false) => {\n      if (unset) {\n        delete usedStateRef.current[path];\n      } else {\n        usedStateRef.current[path] = true;\n      }\n    },\n    []\n  );\n\n  return { stateRef, setStateRef, setUsedStateRef };\n};\n","import isPlainObject from \"./isPlainObject\";\n\nconst getIsDirty = (dirty: object): boolean => {\n  const search = (dty: object, found: any[] = []) => {\n    for (const val of Object.values(dty)) {\n      if (val === true) {\n        found.push(val);\n        return found;\n      }\n\n      if (isPlainObject(val)) search(val, found);\n    }\n\n    return found;\n  };\n\n  return !!search(dirty).length;\n};\n\nexport default getIsDirty;\n","import { useEffect, useLayoutEffect } from \"react\";\n\nconst useIsoLayoutEffect =\n  typeof window === \"undefined\" ? useEffect : useLayoutEffect;\n\nexport default useIsoLayoutEffect;\n","/* eslint-disable @typescript-eslint/no-use-before-define */\n\nimport { useCallback, useEffect, useRef } from \"react\";\n\nimport {\n  ClearErrors,\n  Config,\n  Controller,\n  FieldArgs,\n  FieldElement,\n  FieldRef,\n  Fields,\n  FieldValidator,\n  FieldsValue,\n  FormErrors,\n  FormState,\n  FormValues,\n  GetState,\n  Map,\n  Reset,\n  Return,\n  RunValidation,\n  SetDirty,\n  SetError,\n  SetTouched,\n  SetValue,\n  Submit,\n} from \"./types\";\nimport { useIsoLayoutEffect, useLatest, useState } from \"./hooks\";\nimport {\n  arrayToMap,\n  compact,\n  deepMerge,\n  filterErrors,\n  get,\n  isAsyncFunction,\n  isCheckboxInput,\n  isEmptyObject,\n  isFieldElement,\n  isFileInput,\n  isFileList,\n  isFunction,\n  isInputElement,\n  isMultipleSelect,\n  isNumberInput,\n  isPlainObject,\n  isRadioInput,\n  isRangeInput,\n  isUndefined,\n  runWithLowPriority,\n  set,\n  unset,\n  warn,\n} from \"./utils\";\n\nexport default <V extends FormValues = FormValues>({\n  defaultValues = {} as V,\n  validate,\n  validateOnChange = true,\n  validateOnBlur = true,\n  builtInValidationMode = \"message\",\n  shouldRemoveField = true,\n  excludeFields = [],\n  onReset,\n  onSubmit,\n  onError,\n  debug,\n}: Config<V> = {}): Return<V> => {\n  const isInitRef = useRef(true);\n  const formRef = useRef<HTMLFormElement>(null);\n  const fieldsRef = useRef<Fields>({});\n  const fieldArgsRef = useRef<FieldArgs>({});\n  const controllersRef = useRef<Map>({});\n  const excludeFieldsRef = useRef<Map>(arrayToMap(excludeFields));\n  const changedFieldRef = useRef<string>();\n  const formValidatorRef = useLatest(validate);\n  const fieldValidatorsRef = useRef<Record<string, FieldValidator<V>>>({});\n  const onResetRef = useLatest(onReset || (() => undefined));\n  const onSubmitRef = useLatest(onSubmit || (() => undefined));\n  const onErrorRef = useLatest(onError || (() => undefined));\n  const defaultValuesRef = useRef(defaultValues);\n  const initialStateRef = useRef<FormState<V>>({\n    values: defaultValuesRef.current,\n    touched: {},\n    errors: {},\n    isDirty: false,\n    dirty: {},\n    isValidating: false,\n    isValid: true,\n    isSubmitting: false,\n    isSubmitted: false,\n    submitCount: 0,\n  });\n  const { stateRef, setStateRef, setUsedStateRef } = useState<V>(\n    initialStateRef.current,\n    debug\n  );\n\n  const getFields = useCallback(\n    (form: HTMLFormElement) =>\n      Array.from(form.querySelectorAll(\"input,textarea,select\"))\n        .filter((element) => {\n          const field = element as FieldElement;\n          const {\n            type,\n            name,\n            dataset: { rcfExclude },\n          } = field;\n\n          if (/button|image|submit|reset/.test(type)) return false;\n          if (rcfExclude && !name) {\n            warn('ðŸ’¡ react-cool-form > field: Missing the \"name\" attribute.');\n            return false;\n          }\n\n          return (\n            controllersRef.current[name] ||\n            !(rcfExclude || excludeFieldsRef.current[name])\n          );\n        })\n        .reduce((acc: Record<string, any>, cur) => {\n          const field = cur as FieldElement;\n          const { name } = field;\n\n          acc[name] = { ...acc[name], field: cur };\n\n          if (isCheckboxInput(field) || isRadioInput(field))\n            acc[name].options = acc[name].options\n              ? [...acc[name].options, cur]\n              : [cur];\n\n          return acc;\n        }, {}),\n    []\n  );\n\n  const handleUnset = useCallback(\n    (path: string, fieldPath: string, target: any, name: string) =>\n      setStateRef(path, unset(target, name, true), { fieldPath }),\n    [setStateRef]\n  );\n\n  const fieldRef = useCallback<FieldRef<V>>(\n    (validateOrOptions) => (field) => {\n      if (\n        !field?.name ||\n        controllersRef.current[field.name] ||\n        excludeFieldsRef.current[field.name]\n      )\n        return;\n\n      if (isFunction(validateOrOptions)) {\n        fieldValidatorsRef.current[field.name] = validateOrOptions;\n        return;\n      }\n\n      const { validate: validator, ...parsers } = validateOrOptions;\n\n      if (validator) fieldValidatorsRef.current[field.name] = validator;\n      fieldArgsRef.current[field.name] = parsers;\n    },\n    []\n  );\n\n  const getNodeValue = useCallback(\n    (name: string) => {\n      const { field, options } = fieldsRef.current[name];\n      let value = field.value as any;\n\n      if (isInputElement(field)) {\n        if (fieldArgsRef.current[name]?.valueAsNumber) {\n          value = field.valueAsNumber;\n          return value;\n        }\n        if (fieldArgsRef.current[name]?.valueAsDate) {\n          value = field.valueAsDate;\n          return value;\n        }\n      }\n\n      if (isNumberInput(field) || isRangeInput(field))\n        value = field.valueAsNumber || \"\";\n\n      if (isCheckboxInput(field)) {\n        if (options) {\n          const checkboxes = options as HTMLInputElement[];\n\n          if (options.length > 1) {\n            value = checkboxes\n              .filter((checkbox) => checkbox.checked)\n              .map((checkbox) => checkbox.value);\n          } else {\n            value = checkboxes[0].checked;\n          }\n        } else {\n          let checkValues = get(stateRef.current.values, field.name);\n\n          if (Array.isArray(checkValues)) {\n            checkValues = new Set(checkValues);\n\n            if (field.checked) {\n              checkValues.add(value);\n            } else {\n              checkValues.delete(value);\n            }\n\n            value = Array.from(checkValues);\n          } else {\n            value = field.checked;\n          }\n        }\n      }\n\n      if (isRadioInput(field) && options)\n        value =\n          (options as HTMLInputElement[]).find((radio) => radio.checked)\n            ?.value || \"\";\n\n      if (isMultipleSelect(field) && !options)\n        value = Array.from(field.options)\n          .filter((option) => option.selected)\n          .map((option) => option.value);\n\n      if (isFileInput(field)) value = field.files;\n\n      return value;\n    },\n    [stateRef]\n  );\n\n  const setNodeValue = useCallback((name: string, value: any) => {\n    if (!fieldsRef.current[name] || controllersRef.current[name]) return;\n\n    const { field, options } = fieldsRef.current[name];\n\n    if (isCheckboxInput(field)) {\n      const checkboxes = options as HTMLInputElement[];\n\n      if (checkboxes.length > 1) {\n        checkboxes.forEach((checkbox) => {\n          checkbox.checked = Array.isArray(value)\n            ? value.includes(checkbox.value)\n            : !!value;\n        });\n      } else {\n        checkboxes[0].checked = !!value;\n      }\n    } else if (isRadioInput(field)) {\n      (options as HTMLInputElement[]).forEach((radio) => {\n        radio.checked = radio.value === value;\n      });\n    } else if (isMultipleSelect(field) && Array.isArray(value)) {\n      Array.from(field.options).forEach((option) => {\n        option.selected = !!value.includes(option.value);\n      });\n    } else if (isFileInput(field)) {\n      if (isFileList(value)) field.files = value;\n      if (!value) field.value = \"\";\n    } else {\n      field.value = value ?? \"\";\n    }\n  }, []);\n\n  const setDefaultValue = useCallback(\n    (name: string, value: any) => {\n      if (!isUndefined(get(initialStateRef.current.values, name))) return;\n\n      initialStateRef.current.values = set(\n        initialStateRef.current.values,\n        name,\n        value,\n        true\n      );\n\n      setStateRef(`values.${name}`, get(initialStateRef.current.values, name), {\n        shouldUpdate: !isInitRef.current,\n      });\n    },\n    [setStateRef]\n  );\n\n  const setNodesOrStateValue = useCallback(\n    (\n      values: V,\n      checkDefaultValues = false,\n      fields: FieldsValue[] | string[] = Object.values(fieldsRef.current)\n    ) =>\n      fields.forEach((field: FieldsValue | string) => {\n        const name = isPlainObject(field)\n          ? (field as FieldsValue).field.name\n          : field;\n\n        if (controllersRef.current[name]) return;\n\n        const value = get(values, name);\n\n        if (!isUndefined(value)) setNodeValue(name, value);\n\n        if (checkDefaultValues) {\n          const defaultValue = get(defaultValuesRef.current, name);\n\n          setDefaultValue(\n            name,\n            !isUndefined(defaultValue) ? defaultValue : getNodeValue(name)\n          );\n        }\n      }),\n    [getNodeValue, setDefaultValue, setNodeValue]\n  );\n\n  const getState = useCallback<GetState>(\n    (path, { target, watch = true, errorWithTouched = false } = {}) => {\n      if (!path) return undefined;\n\n      const getPath = (p: string) => {\n        if (p === \"values\" && !target && watch)\n          warn(\n            'ðŸ’¡ react-cool-form > getState: Get the \"values\" alone may cause unnecessary re-renders. If you know what you\\'re doing, please ignore this warning. See: https://react-cool-form.netlify.app/docs/getting-started/form-state#best-practices'\n          );\n\n        p = target ? `${target}.${p}` : p;\n\n        if (watch) setUsedStateRef(p);\n\n        return p;\n      };\n      const errorsEnhancer = (p: string, state: any) => {\n        if (\n          !watch ||\n          !errorWithTouched ||\n          !p.startsWith(\"errors\") ||\n          !state ||\n          isEmptyObject(state)\n        )\n          return state;\n\n        p = p.replace(\"errors\", \"touched\");\n        setUsedStateRef(p);\n\n        return filterErrors(state, get(stateRef.current, p));\n      };\n      let state;\n\n      if (Array.isArray(path)) {\n        state = path.map((p) => {\n          p = getPath(p);\n          return errorsEnhancer(p, get(stateRef.current, p));\n        });\n      } else if (isPlainObject(path)) {\n        const paths = path as Record<string, string>;\n        state = Object.keys(paths).reduce((s: Record<string, any>, key) => {\n          path = getPath(paths[key]);\n          s[key] = errorsEnhancer(path, get(stateRef.current, path));\n          return s;\n        }, {});\n      } else {\n        path = getPath(path);\n        state = errorsEnhancer(path, get(stateRef.current, path));\n      }\n\n      return state;\n    },\n    [setUsedStateRef, stateRef]\n  );\n\n  const setError = useCallback<SetError>(\n    (name, error) => {\n      error = isFunction(error)\n        ? error(get(stateRef.current.errors, name))\n        : error;\n\n      if (error) {\n        setStateRef(`errors.${name}`, error);\n      } else {\n        handleUnset(\"errors\", `errors.${name}`, stateRef.current.errors, name);\n      }\n    },\n    [handleUnset, setStateRef, stateRef]\n  );\n\n  const clearErrors = useCallback<ClearErrors>(\n    (name) => {\n      if (!name) {\n        setStateRef(\"errors\", {});\n      } else if (Array.isArray(name)) {\n        name.forEach((n) =>\n          handleUnset(\"errors\", `errors.${n}`, stateRef.current.errors, n)\n        );\n      } else {\n        handleUnset(\"errors\", `errors.${name}`, stateRef.current.errors, name);\n      }\n    },\n    [handleUnset, setStateRef, stateRef]\n  );\n\n  const runBuiltInValidation = useCallback(\n    (name: string) => {\n      if (builtInValidationMode === false || !fieldsRef.current[name])\n        return undefined;\n\n      const { field } = fieldsRef.current[name];\n\n      if (builtInValidationMode === \"message\") return field.validationMessage;\n\n      for (const k in field.validity) {\n        // @ts-expect-error\n        if (k !== \"valid\" && field.validity[k]) return k;\n      }\n\n      return undefined;\n    },\n    [builtInValidationMode]\n  );\n\n  const runAllBuiltInValidation = useCallback(() => {\n    if (builtInValidationMode === false) return {};\n\n    return Object.keys(fieldsRef.current).reduce((errors, name) => {\n      const error = runBuiltInValidation(name);\n      errors = { ...errors, ...(error ? set({}, name, error) : {}) };\n      return errors;\n    }, {});\n  }, [builtInValidationMode, runBuiltInValidation]);\n\n  const runFieldValidation = useCallback(\n    async (name: string): Promise<any> => {\n      if (!fieldValidatorsRef.current[name]) return undefined;\n\n      try {\n        const error = await fieldValidatorsRef.current[name](\n          get(stateRef.current.values, name),\n          stateRef.current.values\n        );\n\n        return error;\n      } catch (exception) {\n        warn(`ðŸ’¡ react-cool-form > validate ${name}: `, exception);\n        throw exception;\n      }\n    },\n    [stateRef]\n  );\n\n  const runAllFieldsValidation = useCallback((): Promise<FormErrors<V>> => {\n    const promises = Object.keys(fieldValidatorsRef.current).map((name) =>\n      runFieldValidation(name)\n    );\n\n    return Promise.all(promises).then((errors) =>\n      Object.keys(fieldValidatorsRef.current).reduce((acc, cur, idx) => {\n        acc = { ...acc, ...(errors[idx] ? set({}, cur, errors[idx]) : {}) };\n        return acc;\n      }, {})\n    );\n  }, [runFieldValidation]);\n\n  const runFormValidation = useCallback(\n    async (name?: string): Promise<any> => {\n      if (!formValidatorRef.current) return name ? undefined : {};\n\n      try {\n        const errors = await formValidatorRef.current(stateRef.current.values);\n\n        if (name) return get(errors, name);\n\n        return isPlainObject(errors) ? errors : {};\n      } catch (exception) {\n        warn(`ðŸ’¡ react-cool-form > validate form: `, exception);\n        throw exception;\n      }\n    },\n    [formValidatorRef, stateRef]\n  );\n\n  const validateField = useCallback(\n    async (name: string) => {\n      const hasAsyncValidator =\n        isAsyncFunction(formValidatorRef.current) ||\n        isAsyncFunction(fieldValidatorsRef.current[name]);\n\n      if (hasAsyncValidator) setStateRef(\"isValidating\", true);\n\n      try {\n        const error =\n          (await runFormValidation(name)) ||\n          (await runFieldValidation(name)) ||\n          runBuiltInValidation(name);\n\n        setError(name, error);\n        if (hasAsyncValidator) setStateRef(\"isValidating\", false);\n\n        return error;\n      } catch (exception) {\n        return exception;\n      }\n    },\n    [\n      formValidatorRef,\n      runBuiltInValidation,\n      runFieldValidation,\n      runFormValidation,\n      setError,\n      setStateRef,\n    ]\n  );\n\n  const validateFieldWithLowPriority = useCallback<typeof validateField>(\n    (name) => runWithLowPriority(() => validateField(name)),\n    [validateField]\n  );\n\n  const validateForm = useCallback((): Promise<FormErrors<V>> => {\n    setStateRef(\"isValidating\", true);\n\n    return Promise.all([\n      runAllBuiltInValidation(),\n      runAllFieldsValidation(),\n      runFormValidation(),\n    ]).then((errors) => {\n      const errs = deepMerge(...errors);\n\n      setStateRef(\"errors\", errs);\n      setStateRef(\"isValidating\", false);\n\n      return errs;\n    });\n  }, [\n    runAllBuiltInValidation,\n    runAllFieldsValidation,\n    runFormValidation,\n    setStateRef,\n  ]);\n\n  const runValidation = useCallback<RunValidation>(\n    (name) => {\n      if (!name) return validateForm().then((errors) => isEmptyObject(errors));\n\n      if (Array.isArray(name))\n        return Promise.all(name.map((n) => validateField(n))).then(\n          (errors) => !compact(errors).length\n        );\n\n      return validateField(name).then((error) => !error);\n    },\n    [validateField, validateForm]\n  );\n\n  const setTouched = useCallback<SetTouched>(\n    (name, isTouched = true, shouldValidate = validateOnBlur) => {\n      if (isTouched) {\n        setStateRef(`touched.${name}`, true);\n      } else {\n        handleUnset(\n          \"touched\",\n          `touched.${name}`,\n          stateRef.current.touched,\n          name\n        );\n      }\n\n      if (shouldValidate) validateFieldWithLowPriority(name);\n    },\n    [\n      handleUnset,\n      setStateRef,\n      stateRef,\n      validateFieldWithLowPriority,\n      validateOnBlur,\n    ]\n  );\n\n  const setTouchedMaybeValidate = useCallback(\n    (name: string) =>\n      setTouched(\n        name,\n        true,\n        validateOnChange ? name !== changedFieldRef.current : undefined\n      ),\n    [setTouched, validateOnChange]\n  );\n\n  const setDirty = useCallback<SetDirty>(\n    (name, isDirty = true) => {\n      if (isDirty) {\n        setStateRef(`dirty.${name}`, true);\n      } else {\n        handleUnset(\"dirty\", `dirty.${name}`, stateRef.current.dirty, name);\n      }\n    },\n    [handleUnset, setStateRef, stateRef]\n  );\n\n  const setDirtyIfNeeded = useCallback(\n    (name: string) =>\n      setDirty(\n        name,\n        get(stateRef.current.values, name) !==\n          get(initialStateRef.current.values, name)\n      ),\n    [setDirty, stateRef]\n  );\n\n  const setValue = useCallback<SetValue>(\n    (\n      name,\n      value,\n      {\n        shouldValidate = validateOnChange,\n        shouldTouched = true,\n        shouldDirty = true,\n      } = {}\n    ) => {\n      value = isFunction(value)\n        ? value(get(stateRef.current.values, name))\n        : value;\n\n      if (!isUndefined(value)) {\n        setStateRef(`values.${name}`, value);\n      } else {\n        handleUnset(\"values\", `values.${name}`, stateRef.current.values, name);\n      }\n      setNodeValue(name, value);\n\n      if (shouldTouched) setTouched(name, true, false);\n      if (shouldDirty) setDirtyIfNeeded(name);\n      if (shouldValidate) validateFieldWithLowPriority(name);\n    },\n    [\n      handleUnset,\n      setDirtyIfNeeded,\n      setNodeValue,\n      setStateRef,\n      setTouched,\n      stateRef,\n      validateFieldWithLowPriority,\n      validateOnChange,\n    ]\n  );\n\n  const getOptions = useCallback(\n    () => ({\n      formState: stateRef.current,\n      setValue,\n      setTouched,\n      setDirty,\n      setError,\n      clearErrors,\n      runValidation,\n      reset,\n      submit,\n    }),\n    [\n      clearErrors,\n      // @ts-expect-error\n      reset,\n      runValidation,\n      setDirty,\n      setError,\n      setTouched,\n      setValue,\n      stateRef,\n      // @ts-expect-error\n      submit,\n    ]\n  );\n\n  const reset: Reset<V> = useCallback(\n    (values, exclude, e) => {\n      e?.preventDefault();\n      e?.stopPropagation();\n\n      const state = { ...stateRef.current };\n      const skip = arrayToMap(exclude || []);\n\n      Object.keys(state).forEach((key) => {\n        if (skip[key]) return;\n\n        if (key === \"values\") {\n          const nextValues =\n            (isFunction(values) ? values(stateRef.current.values) : values) ||\n            initialStateRef.current.values;\n\n          state[key] = nextValues;\n          initialStateRef.current.values = nextValues;\n          setNodesOrStateValue(initialStateRef.current.values, !!values);\n        } else {\n          // @ts-expect-error\n          state[key] = initialStateRef.current[key];\n        }\n      });\n\n      setStateRef(\"\", state);\n      onResetRef.current(state.values, getOptions(), e);\n    },\n    [getOptions, onResetRef, setNodesOrStateValue, setStateRef, stateRef]\n  );\n\n  const submit: Submit<V> = useCallback(\n    async (e) => {\n      e?.preventDefault();\n      e?.stopPropagation();\n\n      const nextTouched = Object.keys({\n        ...fieldsRef.current,\n        ...controllersRef.current,\n      }).reduce((touched, name) => {\n        touched = set(touched, name, true, true);\n        return touched;\n      }, stateRef.current.touched);\n\n      setStateRef(\"touched\", nextTouched);\n      setStateRef(\"isSubmitting\", true);\n\n      try {\n        const errors = await validateForm();\n\n        if (!isEmptyObject(errors)) {\n          onErrorRef.current(errors, getOptions(), e);\n\n          return { errors };\n        }\n\n        await onSubmitRef.current(stateRef.current.values, getOptions(), e);\n        setStateRef(\"isSubmitted\", true);\n\n        return { values: stateRef.current.values };\n      } catch (exception) {\n        warn(`ðŸ’¡ react-cool-form > submit: `, exception);\n        throw exception;\n      } finally {\n        setStateRef(\"isSubmitting\", false);\n      }\n    },\n    [getOptions, onErrorRef, onSubmitRef, setStateRef, stateRef, validateForm]\n  );\n\n  const handleChangeEvent = useCallback(\n    (name: string, value: any) => {\n      setStateRef(`values.${name}`, value);\n      setDirtyIfNeeded(name);\n\n      if (validateOnChange) validateFieldWithLowPriority(name);\n    },\n    [\n      setDirtyIfNeeded,\n      setStateRef,\n      validateFieldWithLowPriority,\n      validateOnChange,\n    ]\n  );\n\n  const controller = useCallback<Controller<V>>(\n    (\n      name,\n      {\n        validate: validator,\n        value,\n        defaultValue,\n        parse,\n        format,\n        onChange,\n        onBlur,\n      } = {}\n    ) => {\n      if (!name) {\n        warn('ðŸ’¡ react-cool-form > controller: Missing the \"name\" parameter.');\n        return undefined;\n      }\n\n      controllersRef.current[name] = true;\n      if (validator) fieldValidatorsRef.current[name] = validator;\n\n      const val = get(defaultValuesRef.current, name);\n      defaultValue = !isUndefined(val) ? val : defaultValue;\n      if (!isUndefined(defaultValue)) setDefaultValue(name, defaultValue);\n\n      value = !isUndefined(value) ? value : getState(`values.${name}`);\n      value = (format ? format(value) : value) ?? \"\";\n\n      return {\n        name,\n        value,\n        onChange: (...args) => {\n          let v;\n\n          if (parse) {\n            v = parse(...args);\n          } else {\n            const e = args[0];\n            v =\n              e?.nativeEvent instanceof Event && isFieldElement(e.target)\n                ? getNodeValue(name)\n                : e;\n          }\n\n          handleChangeEvent(name, v);\n          if (onChange) onChange(...args, v);\n          changedFieldRef.current = name;\n        },\n        onBlur: (e) => {\n          setTouchedMaybeValidate(name);\n          if (onBlur) onBlur(e);\n          changedFieldRef.current = undefined;\n        },\n      };\n    },\n    [\n      getNodeValue,\n      getState,\n      handleChangeEvent,\n      setDefaultValue,\n      setTouchedMaybeValidate,\n    ]\n  );\n\n  useIsoLayoutEffect(() => {\n    if (!formRef.current) return;\n\n    fieldsRef.current = getFields(formRef.current);\n    setNodesOrStateValue(initialStateRef.current.values, true);\n    isInitRef.current = false;\n  }, [getFields, setNodesOrStateValue]);\n\n  useEffect(() => {\n    if (!formRef.current) return () => null;\n\n    const handleChange = ({ target }: Event) => {\n      const { name } = target as FieldElement;\n\n      if (!name) {\n        warn('ðŸ’¡ react-cool-form > field: Missing the \"name\" attribute.');\n        return;\n      }\n\n      if (fieldsRef.current[name] && !controllersRef.current[name]) {\n        const parse = fieldArgsRef.current[name]?.parse;\n        const value = getNodeValue(name);\n\n        handleChangeEvent(name, parse ? parse(value) : value);\n        changedFieldRef.current = name;\n      }\n    };\n\n    const handleBlur = ({ target }: Event) => {\n      if (!isFieldElement(target as HTMLElement)) return;\n\n      const { name } = target as FieldElement;\n\n      if (fieldsRef.current[name] && !controllersRef.current[name]) {\n        setTouchedMaybeValidate(name);\n        changedFieldRef.current = undefined;\n      }\n    };\n\n    const handleSubmit = (e: Event) => submit(e as any);\n\n    const handleReset = (e: Event) => reset(null, null, e as any);\n\n    const form = formRef.current;\n    form.addEventListener(\"input\", handleChange);\n    form.addEventListener(\"focusout\", handleBlur);\n    form.addEventListener(\"submit\", handleSubmit);\n    form.addEventListener(\"reset\", handleReset);\n\n    const observer = new MutationObserver(([{ type }]) => {\n      if (type !== \"childList\") return;\n\n      const fields = getFields(form);\n      let { values } = stateRef.current;\n\n      if (shouldRemoveField)\n        Object.keys(fieldsRef.current).forEach((name) => {\n          if (fields[name]) return;\n\n          handleUnset(\n            \"values\",\n            `values.${name}`,\n            stateRef.current.values,\n            name\n          );\n          handleUnset(\n            \"touched\",\n            `touched.${name}`,\n            stateRef.current.touched,\n            name\n          );\n          handleUnset(\"dirty\", `dirty.${name}`, stateRef.current.dirty, name);\n          handleUnset(\n            \"errors\",\n            `errors.${name}`,\n            stateRef.current.errors,\n            name\n          );\n          setUsedStateRef(name, true);\n\n          initialStateRef.current.values = unset(\n            initialStateRef.current.values,\n            name,\n            true\n          );\n          delete fieldArgsRef.current[name];\n          delete fieldValidatorsRef.current[name];\n          delete controllersRef.current[name];\n        });\n\n      const addedNodes: string[] = [];\n\n      Object.keys(fields).forEach((name) => {\n        if (fieldsRef.current[name] || controllersRef.current[name]) return;\n\n        const defaultValue = get(defaultValuesRef.current, name);\n\n        if (!isUndefined(defaultValue))\n          values = set(values, name, defaultValue, true);\n\n        addedNodes.push(name);\n      });\n\n      fieldsRef.current = fields;\n      if (addedNodes.length) setNodesOrStateValue(values, true, addedNodes);\n    });\n    observer.observe(form, { childList: true, subtree: true });\n\n    return () => {\n      form.removeEventListener(\"input\", handleChange);\n      form.removeEventListener(\"focusout\", handleBlur);\n      form.removeEventListener(\"submit\", handleSubmit);\n      form.removeEventListener(\"reset\", handleReset);\n      observer.disconnect();\n    };\n  }, [\n    getFields,\n    getNodeValue,\n    handleChangeEvent,\n    handleUnset,\n    reset,\n    setNodesOrStateValue,\n    setTouchedMaybeValidate,\n    setUsedStateRef,\n    shouldRemoveField,\n    stateRef,\n    submit,\n  ]);\n\n  return {\n    form: formRef,\n    field: fieldRef,\n    getState,\n    setValue,\n    setTouched,\n    setDirty,\n    setError,\n    clearErrors,\n    runValidation,\n    reset,\n    submit,\n    controller,\n  };\n};\n","export default (element: HTMLElement): element is HTMLInputElement =>\n  element.tagName === \"INPUT\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"number\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"range\";\n","export default (callback: (args: any) => any): any =>\n  (\n    window.requestIdleCallback ||\n    ((cb) => {\n      const start = Date.now();\n      return setTimeout(\n        () =>\n          cb({\n            didTimeout: false,\n            timeRemaining: () => Math.max(0, 50 - (Date.now() - start)),\n          }),\n        1\n      );\n    })\n  )(callback, { timeout: 2000 });\n"],"names":["val","ref","useRef","useEffect","current","arr","reduce","obj","key","value","FileList","cloneObject","object","Event","Error","isObject","isFileList","Date","getTime","Array","isArray","map","Object","keys","filter","Boolean","deepMerge","objects","prev","forEach","prevValue","currValue","isPlainObject","undefined","filterErrors","error","touched","nextErrors","isUndefined","str","TypeError","length","compact","split","path","defaultValue","stringToPath","isFunction","constructor","name","field","type","element","test","tagName","immutable","segs","newObject","slice","idx","nextIsNumber","Number","isNaN","refObject","hasOwnProperty","last","pop","target","initialState","onChange","forceUpdate","useReducer","c","stateRef","usedStateRef","onChangeRef","useLatest","setStateRef","useCallback","fieldPath","shouldUpdate","dequal","get","state","set","errors","dirty","prevIsDirty","isDirty","prevIsValid","isValid","prevSubmitCount","submitCount","search","dty","found","values","push","getIsDirty","isEmptyObject","some","k","startsWith","setUsedStateRef","unset","useIsoLayoutEffect","window","useLayoutEffect","defaultValues","validate","validateOnChange","validateOnBlur","builtInValidationMode","shouldRemoveField","excludeFields","onReset","onSubmit","onError","debug","isInitRef","formRef","fieldsRef","fieldArgsRef","controllersRef","excludeFieldsRef","arrayToMap","changedFieldRef","formValidatorRef","fieldValidatorsRef","onResetRef","onSubmitRef","onErrorRef","defaultValuesRef","initialStateRef","isValidating","isSubmitting","isSubmitted","useState","getFields","form","from","querySelectorAll","rcfExclude","dataset","acc","cur","isCheckboxInput","isRadioInput","options","handleUnset","fieldRef","validateOrOptions","validator","parsers","getNodeValue","_fieldArgsRef$current","valueAsNumber","_fieldArgsRef$current2","valueAsDate","isNumberInput","isRangeInput","checkboxes","checkbox","checked","checkValues","Set","add","find","radio","isMultipleSelect","option","selected","isFileInput","files","setNodeValue","includes","setDefaultValue","setNodesOrStateValue","checkDefaultValues","fields","getState","watch","errorWithTouched","getPath","p","errorsEnhancer","replace","paths","s","setError","clearErrors","n","runBuiltInValidation","validationMessage","validity","runAllBuiltInValidation","runFieldValidation","async","exception","runAllFieldsValidation","promises","Promise","all","then","runFormValidation","validateField","hasAsyncValidator","isAsyncFunction","validateFieldWithLowPriority","callback","requestIdleCallback","cb","start","now","setTimeout","didTimeout","timeRemaining","Math","max","timeout","validateForm","errs","runValidation","setTouched","isTouched","shouldValidate","setTouchedMaybeValidate","setDirty","setDirtyIfNeeded","setValue","shouldTouched","shouldDirty","getOptions","formState","reset","submit","exclude","e","preventDefault","stopPropagation","skip","nextValues","nextTouched","handleChangeEvent","controller","parse","format","onBlur","v","args","nativeEvent","isFieldElement","handleChange","_fieldArgsRef$current3","handleBlur","handleSubmit","handleReset","addEventListener","observer","MutationObserver","addedNodes","observe","childList","subtree","removeEventListener","disconnect"],"mappings":"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"}